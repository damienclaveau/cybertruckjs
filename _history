{"entries":[{"timestamp":1759750628265,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":673,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":118,"length1":75,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":185,"length1":131,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":244,"length1":45,"diffs":[[1,"    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n"]]}]},{"type":"added","filename":"logger.ts","value":"namespace logger {\n    /**\n     * Converts elapsed milliseconds to a formatted time string\n     * @param elapsedMs - The elapsed time in milliseconds\n     * @returns Formatted string in mm:ss:ms format\n     */\n    function formatElapsedTime(elapsedMs: number): string {\n        // Ensure non-negative value\n        const totalMs = Math.max(0, Math.floor(elapsedMs));\n        // Extract components\n        const minutes = Math.floor(totalMs / 60000);\n        const seconds = Math.floor((totalMs % 60000) / 1000);\n        const milliseconds = totalMs % 1000;\n        // Format with leading zeros using custom padding\n        const formattedMinutes = (minutes < 10 ? \"0\" : \"\") + minutes.toString();\n        const formattedSeconds = (seconds < 10 ? \"0\" : \"\") + seconds.toString();\n        const formattedMs = (milliseconds < 100 ? (milliseconds < 10 ? \"00\" : \"0\") : \"\") + milliseconds.toString();\n        return `${formattedMinutes}:${formattedSeconds}:${formattedMs}`;\n    }\n\n    function get_log_msg(logmsg: string): string {\n        return \"[\" + control.deviceName() + \"@\" + (\"\" + (\"\" + formatElapsedTime(control.millis()))) + \" (\" + cyclesCount + \")]\" + \" : \" + logmsg\n    }\n    // Logging function to Serial Monitor or Bluetooth\n    export function log(msg: string) {\n        msg = get_log_msg(msg);\n        switch (EXEC_MODE) {\n            case ExecMode.MakeCode:\n            case ExecMode.WiredMode:\n                serial.writeLine(msg);\n                //console.log(msg);\n                break;\n            case ExecMode.GameMode:\n            case ExecMode.FreeMode:\n                // disabled for the moment\n                //if (bluetooth_connected){ bluetooth.uartWriteLine(msg) }\n\n                // the radio channel is used for communication with the game controller\n                // so we cannot use it for logging\n                //radio.sendString(msg);\n                break;\n            default:\n                break;\n        }\n    }\n\n    export function send_telemetry() {\n        //  Log metrics and update Display\n        if (HUSKY_WIRED) {\n            //    huskylens.writeOSD(\"angle diff \"+str(steering_angle), 150, 30)\n            //    huskylens.writeOSD(\"servo_angle \"+str(servo_angle), 150, 60)\n            //    huskylens.writeOSD(\"input \"+str(steering_value), 150, 90)\n            //huskylens.writeOSD(\"balls \" + (\"\" + vision.balls.length), 150, 120)\n        }\n\n        if ([ExecMode.MakeCode, ExecMode.WiredMode].indexOf(EXEC_MODE) >= 0) {\n            //datalogger.log(datalogger.createCV(\"balls\", vision.balls.length))\n        }\n    }\n}"},{"type":"added","filename":"controller.ts","value":"/**\n * PCA9685 PWM Controller Abstraction Layer\n * Controls servos through I2C communication with the PCA9685 chip\n * \n * This module provides both low-level PCA9685 control and high-level servo control\n * for the DFR0548 micro:bit expansion board with 270-degree servos.\n */\n\n/**\n * Low-level PCA9685 PWM Controller\n */\nnamespace PCA9685 {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    let initialized = false\n\n    function i2cWrite(reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    function i2cRead(reg: number): number {\n        pins.i2cWriteNumber(PCA9685_ADDRESS, reg, NumberFormat.UInt8BE)\n        return pins.i2cReadNumber(PCA9685_ADDRESS, NumberFormat.UInt8BE)\n    }\n\n    function setPWM(channel: number, on: number, off: number) {\n        if (channel < 0 || channel > 15) return\n\n        let buf = pins.createBuffer(5)\n        buf[0] = LED0_ON_L + 4 * channel\n        buf[1] = on & 0xff\n        buf[2] = (on >> 8) & 0x0f\n        buf[3] = off & 0xff\n        buf[4] = (off >> 8) & 0x0f\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    export function init() {\n        if (initialized) return\n\n        // Reset PCA9685\n        i2cWrite(MODE1, 0x00)\n        basic.pause(10)\n\n        // Set PWM frequency to 50Hz (for servos)\n        setFrequency(50)\n\n        initialized = true\n    }\n\n    function setFrequency(freq: number) {\n        let prescaleval = 25000000    // 25MHz\n        prescaleval /= 4096           // 12-bit\n        prescaleval /= freq\n        prescaleval -= 1\n        let prescale = Math.floor(prescaleval + 0.5)\n\n        let oldmode = i2cRead(MODE1)\n        let newmode = (oldmode & 0x7F) | 0x10  // sleep\n        i2cWrite(MODE1, newmode)               // go to sleep\n        i2cWrite(PRESCALE, prescale)           // set prescaler\n        i2cWrite(MODE1, oldmode)\n        basic.pause(5)\n        i2cWrite(MODE1, oldmode | 0xa1)        // restart + auto increment\n    }\n\n    /**\n     * Set servo angle on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     * @param angle Servo angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServoChannel(channel: number, angle: number) {\n        if (!initialized) init()\n\n        // Clamp angle to valid range\n        angle = Math.min(90, Math.max(-90, angle))\n\n        // Use measured calibration values:\n        // -90° = 199 PWM, 0° = 333 PWM, +90° = 472 PWM\n        // Linear interpolation: PWM = center + (angle/90) * range\n        let centerPWM = 333\n        let rangePWM = 472 - 199  // Total range = 273 PWM ticks\n        let halfRange = rangePWM / 2  // 136.5 PWM ticks for ±90°\n\n        let pwmTicks = Math.round(centerPWM + (angle / 90) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(472, Math.max(199, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set servo with raw PWM ticks for calibration\n     * @param channel PWM channel (0-15)  \n     * @param pwmTicks Raw PWM value (0-4095)\n     */\n    export function setServoRawPWM(channel: number, pwmTicks: number) {\n        if (!initialized) init()\n        pwmTicks = Math.min(4095, Math.max(0, pwmTicks))\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set motor PWM for speed control\n     * @param channel PWM channel (0-15)\n     * @param speed speed value (-100 to 100, where 0 is stopped)\n     */\n    export function setMotorChannel(channel: number, speed: number) {\n        if (!initialized) init()\n\n        // Clamp speed to valid range\n        speed = Math.min(100, Math.max(-100, speed))\n\n        let centerPWM = 320\n        let rangePWM = 540 - 100\n        let halfRange = rangePWM / 2\n\n        let pwmTicks = Math.round(centerPWM + (speed / 100) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(540, Math.max(100, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Stop servo on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     */\n    export function stopServoChannel(channel: number) {\n        setPWM(channel, 0, 0)\n    }\n}\n\nconst SERVO_CHANNELS = [15, 14, 13, 12, 11, 10, 9, 8]\n\n/**\n * High-Level Servo Controller for DFR0548 Expansion Board\n * Maps servo ports S1-S8 to PCA9685 channels\n */\nnamespace ServoController {\n    /**\n     * Initialize the servo controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param angle Angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServo(servoPort: number, angle: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoChannel(channel, angle)\n    }\n\n    /**\n     * Stop servo by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     */\n    export function stopServo(servoPort: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.stopServoChannel(channel)\n    }\n\n    /**\n     * Set all servos to center position (0 degrees)\n     */\n    export function centerAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            setServo(i, 0)\n        }\n    }\n\n    /**\n     * Stop all servos\n     */\n    export function stopAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            stopServo(i)\n        }\n    }\n\n    /**\n     * Test all servos with a movement sequence\n     */\n    export function testAllServos(servos: number[]) {\n        for (let i = 0; i < servos.length; i++) {\n            let servoNum = servos[i]\n            setServo(servoNum, -90)\n            basic.pause(500)\n            setServo(servoNum, 90)\n            basic.pause(500)\n            setServo(servoNum, 0)\n        }\n    }\n\n    /**\n     * Set servo with custom PWM value for fine-tuning\n     */\n    export function setServoRawPWM(servoPort: number, pwmValue: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}\n\n/**\n * Motor Controller for DFR0548 Expansion Board\n * Controls DC motors through PWM speed control\n * Maps motor ports M1-M4 to PCA9685 channels 0-3\n */\nnamespace MotorController {\n\n    /**\n     * Initialize the motor controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param speed Angle in degrees (-100 to +100, where 0 is neutral)\n     */\n    export function setMotor(servoPort: number, speed: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setMotorChannel(channel, -speed)\n    }\n\n    /**\n     * Test all motors with a speed sequence\n     */\n    export function testAllMotors(motors: number[]) {\n        // Test each motor with different speeds\n        for (let i = 0; i < motors.length; i++) {\n            let motorNum = motors[i]\n\n            // Test 50% speed\n            setMotor(motorNum, 50)\n            basic.pause(200)\n\n            // Test 100% speed\n            setMotor(motorNum, 100)\n            basic.pause(200)\n\n            // Stop motor\n            setMotor(motorNum, 0)\n            basic.pause(500)\n\n            // Test -50% speed\n            setMotor(motorNum, -50)\n            basic.pause(200)\n\n            // Test -100% speed\n            setMotor(motorNum, -100)\n            basic.pause(200)\n\n            setMotor(motorNum, 0)\n        }\n        basic.pause(500)\n    }\n\n    /**\n     * Set motor with custom PWM value for fine-tuning\n     * @param motorPort Motor port number (1-4)\n     * @param pwmValue Raw PWM value (0-4095)\n     */\n    export function setMotorRawPWM(motorPort: number, pwmValue: number) {\n        if (motorPort < 1 || motorPort > 8) return\n\n        let channel = SERVO_CHANNELS[motorPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}// Add your code here\n"},{"type":"added","filename":"position.ts","value":"namespace position {\n\n    class OccupancyGrid {\n\n    }\n\n    export function updateSensors() {\n        //  Update Compass direction, current speed, deviation, commands coming from Bluetooth, ...\n        //  TO DO Compute current position with sensor fusion https://github.com/micropython-IMU/micropython-fusion/tree/master\n        let compass_heading = input.compassHeading()\n        let mag_x = input.magneticForce(Dimension.X)\n        let mag_y = input.magneticForce(Dimension.Y)\n        let mag_z = input.magneticForce(Dimension.Z)\n        let acc_x = input.acceleration(Dimension.X)\n        let acc_y = input.acceleration(Dimension.Y)\n        let acc_z = input.acceleration(Dimension.Z)\n        let acceleration = Math.sqrt(acc_x ** 2 + acc_y ** 2 + acc_z ** 2)\n    }\n\n    export function updateEnvironment() {\n        // re-compute the occupancy grid : QRCodes cardinals, home location, balls clusters, robots\n        // approximate the Robot orientation and position\n    }\n}"},{"type":"added","filename":"motion.ts","value":"namespace motion {\n\n    enum MotionDirection {\n        Idle,\n        Forward,\n        Backward,\n        Spinning\n    }\n\n    class Waypoint {\n        distance: number  //  mm\n        angle: number // radians\n        constructor(distance: number, angle: number) {\n            this.distance = distance\n            this.angle = angle\n        }\n    }\n\n    /*\n    ServoController.setServo(DIRECTION_SERVO, -45) //turn right\n    ServoController.setServo(DIRECTION_SERVO, 0) //straight\n    ServoController.setServo(DIRECTION_SERVO, 45) //turn left\n    MotorController.setMotor(SPEED_MOTOR, -100) //backward max speed\n    MotorController.setMotor(SPEED_MOTOR, 100) //forward max speed\n    */\n    export function goToWaypoint(waypoint: Waypoint) {\n        //  Drive servo and motor with PWM according to updated linear and angular velocities\n        //  Set the steering servo position to aim to the waypoint\n        let steering = 0\n        //  to be computed with PID\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P0.setAngle(steering)\n        } else {\n            ServoController.setServo(DIRECTION_SERVO, steering)\n        }\n\n        //  Set the servo throttle power depending on the remaining distance to the waypoint\n        let speed = 0\n        /*\n        // just for testing purpose\n        if (waypoint.distance > 60)\n            speed = 100\n        else if (waypoint.distance > 0)\n            speed = 50\n        */\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P1.run(speed)\n        } else {\n            MotorController.setMotor(SPEED_MOTOR, speed)\n        }\n\n    }\n\n}\n"},{"type":"added","filename":"vision.ts","value":"namespace vision_ns {\n\n    const HUSKY_SCREEN_WIDTH = 320; // pixels\n    const HUSKY_SCREEN_HEIGHT = 240; // pixels\n    const HUSKY_SCREEN_CENTER_X = HUSKY_SCREEN_WIDTH / 2;\n    const HUSKY_SCREEN_CENTER_Y = HUSKY_SCREEN_HEIGHT / 2;\n    const HUSKY_SCREEN_TOLERANCE_X = 10; // pixels\n\n    const BALL_REFERENCE_DISTANCE = 50; // (cm)\n    const BALL_REFERENCE_FRAMESIZE = 30; // (pixels) width and height of a ball frame at 50 cm distance\n    const BALL_DISTANCE_RATIO = BALL_REFERENCE_DISTANCE / BALL_REFERENCE_FRAMESIZE;\n\n    // Screen Side Class\n    export enum ScreenSide {\n        Left,\n        Right,\n        Middle\n    }\n\n    // QR Codes Configuration\n    const QR_CODES = [\n        { code: \"id300\", cardinal: \"East\", husky_learned_id: 1 },\n        { code: \"id301\", cardinal: \"South\", husky_learned_id: 2 },\n        { code: \"id302\", cardinal: \"West\", husky_learned_id: 3 },\n        { code: \"id303\", cardinal: \"North\", husky_learned_id: 4 },\n        { code: \"id407\", cardinal: \"Base\", husky_learned_id: 5 }\n    ];\n\n    // QR Code ID as recognized by Husky TagRecognition\n    export class QRcodeId {\n        static East = 1;\n        static South = 2;\n        static West = 3;\n        static North = 4;\n        static Base = 5;\n    }\n\n    // Object Color ID as recognized by Husky ColorRecognition\n    export class ObjectColorID {\n        static Red = 1; // a ball\n        static Yellow = 2; // another robot\n    }\n\n    // Object Class ID as recognized by Husky ObjectClassification\n    export class ObjectClassID {\n        static Unknown = 0;\n        static Ball = 1;\n        static Robot = 2;\n        static QRcode = 3;\n    }\n\n    // Object Kind\n    export enum ObjectKind {\n        Unknown,\n        Ball,\n        Robot,\n        QRcode\n    }\n\n\n    // Visual Object Class\n    export class VisualObject {\n        public x: number = -1\n        public y: number = -1\n        public w: number = -1\n        public h: number = -1\n        public id: number = -1 // ID as returned by Huskylens \n        public kind: ObjectKind = ObjectKind.Unknown\n        public last_seen: number = -1\n        public is_tracked: boolean = false\n        constructor() {\n        }\n\n        setCoordinates(x: number, y: number, w: number, h: number) {\n            // Set the object's coordinates and dimensions. Update LastSeen time.\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n            this.last_seen = input.runningTime();\n        }\n\n        reset() {\n            // Reset the object's coordinates and dimensions.\n            this.setCoordinates(0, 0, 0, 0);\n            this.last_seen = 0;\n        }\n\n        toString() {\n            // Display the object's details.\n            return `kind: ${this.kind} id: ${this.x} x:${this.x} y:${this.y} w:(${this.w} h:${this.h}`;\n        }\n\n        // Get side of the TrackedObject relative to the robot direction\n        getScreenSide() {\n            if (this.x > (HUSKY_SCREEN_CENTER_X + HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Right;\n            } else if (this.x < (HUSKY_SCREEN_CENTER_X - HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Left;\n            } else {\n                return ScreenSide.Middle;\n            }\n        }\n\n        // Compute distance of the TrackedObject based on the visual size ratio\n        getDistance() {\n            const size = Math.sqrt(this.w ** 2 + this.h ** 2); // frame diagonal\n            return (BALL_REFERENCE_FRAMESIZE * BALL_REFERENCE_DISTANCE) / size;\n        }\n\n        // Compute coordinates of the TrackedObject relative to the robot position (origin)\n        getAngle() {\n            const distance = this.getDistance();\n            const deltaX = Math.abs(this.x - HUSKY_SCREEN_CENTER_X);\n            const deltaY = Math.sqrt(distance ** 2 - deltaX ** 2);\n            // Angle between y front-axis and the ball projected coordinates(dx,dy)\n            return Math.atan2(deltaX, deltaY);\n        }\n    }\n\n    // Vision Processor Class\n    export class VisionProcessor {\n        public mode: number\n        public kind: number\n        public tracked: VisualObject\n        public codes: VisualObject[] = [];\n        public balls: VisualObject[] = [];\n        public bots: VisualObject[] = [];\n        public verbose: boolean = true\n        constructor(mode = protocolAlgorithm.ALGORITHM_TAG_RECOGNITION, kind = ObjectKind.QRcode) {\n            this.mode = mode;\n            this.kind = kind;\n            this.tracked = new VisualObject();\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n        }\n\n        setMode(mode: number) {\n            if (this.mode !== mode) {\n                this.mode = mode;\n                huskylens.initMode(this.mode);\n                if (this.verbose) { logger.log(`Mode set to: ${this.mode}`); }\n            }\n        }\n\n        setKind(kind: number) {\n            if (this.kind !== kind) {\n                this.kind = kind;\n                if (this.verbose) { logger.log(`Kind set to: ${this.kind}`); }\n            }\n        }\n\n        init() {\n            huskylens.initI2c();\n            huskylens.initMode(this.mode);\n        }\n\n        refreshForced(mode: number, kind: number) {\n            // Change temporarily the mode and the kind to refresh all objects once\n            const saveMode = this.mode;\n            const saveKind = this.kind;\n            this.setMode(mode);\n            this.setKind(kind);\n            this.refresh();\n            this.setMode(saveMode);\n            this.setKind(saveKind);\n        }\n\n        // Capture a new video frame and analyze it : is there 1 ball, no ball, a Tag, an obstacle or nothing ?\n        refresh() {\n            // Refresh the VisionProcessor.\n            huskylens.request();\n            if (this.verbose) { logger.log(`Husky (mode  ${this.mode}) captured IDs : ${huskylens.getIds()}`) }\n            if (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING) {\n                this.processSingleObject();\n            }\n            if ((this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING)) {\n                this.processAllObjects()\n            }\n        }\n\n        processSingleObject() {\n            // Process a single object in tracking mode.\n            // Frame (== Block type) appears in screen ?\n            this.tracked.is_tracked = huskylens.isAppear_s(HUSKYLENSResultType_t.HUSKYLENSResultBlock)\n            if (this.tracked.is_tracked) {\n                // check if the tracked object is a learnt object \n                if (!huskylens.isLearned(this.kind)) {\n                    if (this.verbose) { logger.log(\"Tracking UNKNOWN object\") }\n                }\n                const objectId = this.kind; // always one single TrackedObject in this mode\n                this.tracked.setCoordinates(\n                    huskylens.readeBox(objectId, Content1.xCenter),\n                    huskylens.readeBox(objectId, Content1.yCenter),\n                    huskylens.readeBox(objectId, Content1.width),\n                    huskylens.readeBox(objectId, Content1.height)\n                );\n                if (this.verbose) { logger.log(\"Tracked Object updated : \" + this.tracked.toString()) }\n\n            } else {\n                // if (input.runningTime() - trackedObject.lastSeen) > OBJECT_LOST_DELAY:\n                this.tracked.reset();\n                if (this.verbose) { logger.log(\"Tracked Object Lost\") }\n            }\n        }\n\n        processAllObjects() {\n            // Process all objects in recognition mode.\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n            // for each frame, Update the relative Position of the QR codes\n            const nbFrames = huskylens.getBox(HUSKYLENSResultType_t.HUSKYLENSResultBlock);\n            if (this.verbose) { logger.log(`Objects on screen : ${nbFrames}`); }\n            for (let i = 1; i <= nbFrames; i++) {\n                const vo = new VisualObject();\n                vo.id = huskylens.readBox_ss(i, Content3.ID);\n                vo.setCoordinates(\n                    huskylens.readBox_ss(i, Content3.xCenter),\n                    huskylens.readBox_ss(i, Content3.yCenter),\n                    huskylens.readBox_ss(i, Content3.width),\n                    huskylens.readBox_ss(i, Content3.height)\n                );\n\n                if (this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION) {\n                    vo.kind = ObjectKind.QRcode\n                    this.codes.push(vo);\n                    if (this.verbose) { logger.log(\"QR Tag found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION) {\n                    if (vo.id === ObjectColorID.Red) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectColorID.Yellow) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Colored object found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.OBJECTCLASSIFICATION) {\n                    if (vo.id === ObjectClassID.Ball) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.Robot) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.QRcode) {\n                        vo.kind = ObjectKind.QRcode\n                        this.codes.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Shaped object found : \" + vo.toString()); }\n                }\n            }\n        }\n    }\n\n}\n"}]},{"timestamp":1759751218317,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":172,"length1":89,"diffs":[[1,"        \"servo\": \"*\"\n"]]}]}]},{"timestamp":1759751232528,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":413,"length1":39,"diffs":[[1,"        \"vision.ts\"\n"]]}]},{"type":"added","filename":"game.ts","value":""}]},{"timestamp":1759751845004,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"game.ts","patch":[{"start1":0,"length1":22,"diffs":[[1,""]]}]}]},{"timestamp":1759751845013,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"game.ts","patch":[{"start1":0,"length1":4099,"diffs":[[1,"// Add your code here\n"]]}]}]},{"timestamp":1759752286828,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":434,"length1":38,"diffs":[[1,"        \"game.ts\"\n"]]}]},{"type":"added","filename":"robot.ts","value":""}]},{"timestamp":1759753611982,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"robot.ts","patch":[{"start1":0,"length1":22,"diffs":[[1,""]]}]}]},{"timestamp":1759753611998,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":140,"length1":520,"diffs":[[1,""]]},{"start1":378,"length1":21,"diffs":[[1,"const FOR_LATER_USE_SERVO = 1\r\nconst DIRECTION_SERVO = 2\r\nconst GRABBER_MOTOR = 3\r\nconst SPEED_MOTOR = 4\r\n\r\n// Parameters\r\nlet HUSKY_WIRED = false; // true if the HuskyLens is wired with I2C\r\n"]]},{"start1":606,"length1":0,"diffs":[[1,"// Global Variables\r\n"]]},{"start1":649,"length1":1567,"diffs":[[1,"let initialized = false;"]]}]},{"type":"edited","filename":"logger.ts","patch":[{"start1":2301,"length1":80,"diffs":[[1,"            //huskylens.writeOSD(\"balls \" + (\"\" + vision.balls.length), 150, 120)\n"]]},{"start1":2473,"length1":78,"diffs":[[1,"            //datalogger.log(datalogger.createCV(\"balls\", vision.balls.length))\n"]]}]},{"type":"edited","filename":"game.ts","patch":[{"start1":1307,"length1":28,"diffs":[[1,"            //robot.doStart()\n"]]},{"start1":1778,"length1":23,"diffs":[[1,"        //robot.doStop()\n"]]},{"start1":2099,"length1":29,"diffs":[[1,"        //robot.askGoingHome()\n"]]},{"start1":2653,"length1":0,"diffs":[[1,"let bricksGame = new BricksGame()\n"]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":22,"length1":5365,"diffs":[[1,""]]}]}]},{"timestamp":1759754103060,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":1388,"length1":83,"diffs":[[1,"    music.setVolume(255)\r\n    music.playMelody(imperial_march.join(\" \"), 150)\r\n"]]},{"start1":2537,"length1":1126,"diffs":[[1,"init();"]]}]},{"type":"edited","filename":"game.ts","patch":[{"start1":1059,"length1":43,"diffs":[[1,""]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":2227,"length1":16,"diffs":[[1,""]]}]}]},{"timestamp":1759754679304,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"game.ts","patch":[{"start1":920,"length1":143,"diffs":[[1,"        music.setTempo(360)\n        music._playDefaultBackground(music.builtInPlayableMelody(Melodies.Funk), music.PlaybackMode.UntilDone)\n"]]},{"start1":1422,"length1":157,"diffs":[[1,"            music.setTempo(360)\n            music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerUp), music.PlaybackMode.InBackground)\n"]]},{"start1":1883,"length1":151,"diffs":[[1,"        music.setTempo(360)\n        music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerDown), music.PlaybackMode.InBackground)\n"]]},{"start1":2361,"length1":213,"diffs":[[1,"        music.setTempo(360)\n        for (let index = 0; index < 4; index++) {\n            music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n        }\n"]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":0,"length1":0,"diffs":[[1,"// Add your code here\n"]]},{"start1":2227,"length1":0,"diffs":[[1,"        return;\n"]]},{"start1":3243,"length1":120,"diffs":[[1,"            if (true) {\n                logger.log(\"Found Balls on screen : \" + 0)\n"]]},{"start1":3715,"length1":174,"diffs":[[1,"            if (true) {\n                logger.log(\"Previous ball LOST or COLLECTED. Back to searching...(on screen Balls: \" + 0 + \")\")\n"]]},{"start1":3941,"length1":106,"diffs":[[1,"                logger.log(\"Tracking the closest ball... (on screen Balls: \" + 0 + \")\")\n"]]}]}]},{"timestamp":1759755267280,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":120,"length1":28,"diffs":[[1,"    class Waypoint {\n"]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":403,"length1":0,"diffs":[[1,"class Waypoint {\n    distance: number  //  mm\n    angle: number // radians\n    constructor(distance: number, angle: number) {\n        this.distance = distance\n        this.angle = angle\n    }\n}\n"]]},{"start1":630,"length1":30,"diffs":[[1,"    waypoint: Waypoint\n"]]}]}]},{"timestamp":1759755313962,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":1261,"length1":0,"diffs":[[1,"        /*\n"]]}]}]},{"timestamp":1759760550347,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":1420,"length1":42,"diffs":[[1,"        */\n        if (EXEC_MODE == ExecMode.MakeCode) {\n"]]}]}]},{"timestamp":1759760554680,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":3572,"length1":28,"diffs":[[1,"    motion.goToWaypoint(robot.waypoint);\r\n"]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":353,"length1":42,"diffs":[[1,""]]},{"start1":354,"length1":141,"diffs":[[1,""]]},{"start1":690,"length1":37,"diffs":[[1,"    export function goToWaypoint(waypoint: Waypoint) {\n"]]},{"start1":1420,"length1":46,"diffs":[[1,"    if (EXEC_MODE == ExecMode.MakeCode) {\n"]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":436,"length1":32,"diffs":[[1,"    waypoint: motion.Waypoint\n"]]},{"start1":4650,"length1":41,"diffs":[[1,"                this.waypoint.distance = 0\n                this.waypoint.angle = 0\n"]]}]}]},{"timestamp":1759761121622,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":396,"length1":8,"diffs":[[1,""]]}]}]},{"timestamp":1759761170961,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":918,"length1":9,"diffs":[[1,""]]}]}]},{"timestamp":1759763039378,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":918,"length1":15,"diffs":[[1,"        \n"]]}]}]},{"timestamp":1759763042796,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"motion.ts","patch":[{"start1":918,"length1":84,"diffs":[[1,"        logger\n"]]}]},{"type":"edited","filename":"vision.ts","patch":[{"start1":3971,"length1":79,"diffs":[[1,""]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":3310,"length1":54,"diffs":[[1,"                logger.log(\"Keep searching...\")\n"]]},{"start1":4808,"length1":43,"diffs":[[1,""]]},{"start1":5040,"length1":156,"diffs":[[1,""]]}]}]},{"timestamp":1759763766630,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"robot.ts","patch":[{"start1":863,"length1":17,"diffs":[[1,""]]}]}]},{"timestamp":1759763856715,"editorVersion":"8.0.16","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":479,"length1":44,"diffs":[[1,""]]}]},{"type":"edited","filename":"motion.ts","patch":[{"start1":1188,"length1":135,"diffs":[[1,"        //  to be computed with PID\n        if (EXEC_MODE == ExecMode.MakeCode) {\n"]]},{"start1":1518,"length1":65,"diffs":[[1,"        // just for testing purpose\n"]]},{"start1":1677,"length1":73,"diffs":[[1,"        if (EXEC_MODE == ExecMode.MakeCode) {\n"]]}]},{"type":"edited","filename":"robot.ts","patch":[{"start1":734,"length1":40,"diffs":[[1,""]]},{"start1":775,"length1":89,"diffs":[[1,"                case RobotState.atHome:\n"]]},{"start1":863,"length1":185,"diffs":[[1,"                \n"]]},{"start1":927,"length1":0,"diffs":[[1,"                case RobotState.trackingBall:\n"]]},{"start1":1016,"length1":144,"diffs":[[1,""]]},{"start1":5262,"length1":79,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1759750628264,"editorVersion":"8.0.16","text":{"main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"CybertruckJS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\",\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1759753611982,"editorVersion":"8.0.16","text":{"main.ts":"// Timing Constants\r\nconst GAME_DURATION = 30; // seconds\r\nconst DELAY_TO_GO_HOME = 20; // seconds\r\nconst OBJECT_LOST_DELAY = 1; // second\r\n// Execution Mode Parameters\r\nenum ExecMode {\r\n    MakeCode, // Offline software development with no attached board\r\n    FreeMode, // Free running Robot\r\n    GameMode, // Board wired with USB\r\n    WiredMode, // Board wired with USB\r\n}\r\n\r\nconst FOR_LATER_USE_SERVO = 1\r\nconst DIRECTION_SERVO = 2\r\nconst GRABBER_MOTOR = 3\r\nconst SPEED_MOTOR = 4\r\n\r\n// Parameters\r\nlet HUSKY_WIRED = false; // true if the HuskyLens is wired with I2C\r\nlet EXEC_MODE = ExecMode.MakeCode;\r\n// Global Variables\r\nlet cyclesCount = 0;\r\nlet initialized = false;","README.md":"","logger.ts":"namespace logger {\n    /**\n     * Converts elapsed milliseconds to a formatted time string\n     * @param elapsedMs - The elapsed time in milliseconds\n     * @returns Formatted string in mm:ss:ms format\n     */\n    function formatElapsedTime(elapsedMs: number): string {\n        // Ensure non-negative value\n        const totalMs = Math.max(0, Math.floor(elapsedMs));\n        // Extract components\n        const minutes = Math.floor(totalMs / 60000);\n        const seconds = Math.floor((totalMs % 60000) / 1000);\n        const milliseconds = totalMs % 1000;\n        // Format with leading zeros using custom padding\n        const formattedMinutes = (minutes < 10 ? \"0\" : \"\") + minutes.toString();\n        const formattedSeconds = (seconds < 10 ? \"0\" : \"\") + seconds.toString();\n        const formattedMs = (milliseconds < 100 ? (milliseconds < 10 ? \"00\" : \"0\") : \"\") + milliseconds.toString();\n        return `${formattedMinutes}:${formattedSeconds}:${formattedMs}`;\n    }\n\n    function get_log_msg(logmsg: string): string {\n        return \"[\" + control.deviceName() + \"@\" + (\"\" + (\"\" + formatElapsedTime(control.millis()))) + \" (\" + cyclesCount + \")]\" + \" : \" + logmsg\n    }\n    // Logging function to Serial Monitor or Bluetooth\n    export function log(msg: string) {\n        msg = get_log_msg(msg);\n        switch (EXEC_MODE) {\n            case ExecMode.MakeCode:\n            case ExecMode.WiredMode:\n                serial.writeLine(msg);\n                //console.log(msg);\n                break;\n            case ExecMode.GameMode:\n            case ExecMode.FreeMode:\n                // disabled for the moment\n                //if (bluetooth_connected){ bluetooth.uartWriteLine(msg) }\n\n                // the radio channel is used for communication with the game controller\n                // so we cannot use it for logging\n                //radio.sendString(msg);\n                break;\n            default:\n                break;\n        }\n    }\n\n    export function send_telemetry() {\n        //  Log metrics and update Display\n        if (HUSKY_WIRED) {\n            //    huskylens.writeOSD(\"angle diff \"+str(steering_angle), 150, 30)\n            //    huskylens.writeOSD(\"servo_angle \"+str(servo_angle), 150, 60)\n            //    huskylens.writeOSD(\"input \"+str(steering_value), 150, 90)\n            //huskylens.writeOSD(\"balls \" + (\"\" + vision.balls.length), 150, 120)\n        }\n\n        if ([ExecMode.MakeCode, ExecMode.WiredMode].indexOf(EXEC_MODE) >= 0) {\n            //datalogger.log(datalogger.createCV(\"balls\", vision.balls.length))\n        }\n    }\n}","controller.ts":"/**\n * PCA9685 PWM Controller Abstraction Layer\n * Controls servos through I2C communication with the PCA9685 chip\n * \n * This module provides both low-level PCA9685 control and high-level servo control\n * for the DFR0548 micro:bit expansion board with 270-degree servos.\n */\n\n/**\n * Low-level PCA9685 PWM Controller\n */\nnamespace PCA9685 {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    let initialized = false\n\n    function i2cWrite(reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    function i2cRead(reg: number): number {\n        pins.i2cWriteNumber(PCA9685_ADDRESS, reg, NumberFormat.UInt8BE)\n        return pins.i2cReadNumber(PCA9685_ADDRESS, NumberFormat.UInt8BE)\n    }\n\n    function setPWM(channel: number, on: number, off: number) {\n        if (channel < 0 || channel > 15) return\n\n        let buf = pins.createBuffer(5)\n        buf[0] = LED0_ON_L + 4 * channel\n        buf[1] = on & 0xff\n        buf[2] = (on >> 8) & 0x0f\n        buf[3] = off & 0xff\n        buf[4] = (off >> 8) & 0x0f\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    export function init() {\n        if (initialized) return\n\n        // Reset PCA9685\n        i2cWrite(MODE1, 0x00)\n        basic.pause(10)\n\n        // Set PWM frequency to 50Hz (for servos)\n        setFrequency(50)\n\n        initialized = true\n    }\n\n    function setFrequency(freq: number) {\n        let prescaleval = 25000000    // 25MHz\n        prescaleval /= 4096           // 12-bit\n        prescaleval /= freq\n        prescaleval -= 1\n        let prescale = Math.floor(prescaleval + 0.5)\n\n        let oldmode = i2cRead(MODE1)\n        let newmode = (oldmode & 0x7F) | 0x10  // sleep\n        i2cWrite(MODE1, newmode)               // go to sleep\n        i2cWrite(PRESCALE, prescale)           // set prescaler\n        i2cWrite(MODE1, oldmode)\n        basic.pause(5)\n        i2cWrite(MODE1, oldmode | 0xa1)        // restart + auto increment\n    }\n\n    /**\n     * Set servo angle on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     * @param angle Servo angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServoChannel(channel: number, angle: number) {\n        if (!initialized) init()\n\n        // Clamp angle to valid range\n        angle = Math.min(90, Math.max(-90, angle))\n\n        // Use measured calibration values:\n        // -90° = 199 PWM, 0° = 333 PWM, +90° = 472 PWM\n        // Linear interpolation: PWM = center + (angle/90) * range\n        let centerPWM = 333\n        let rangePWM = 472 - 199  // Total range = 273 PWM ticks\n        let halfRange = rangePWM / 2  // 136.5 PWM ticks for ±90°\n\n        let pwmTicks = Math.round(centerPWM + (angle / 90) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(472, Math.max(199, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set servo with raw PWM ticks for calibration\n     * @param channel PWM channel (0-15)  \n     * @param pwmTicks Raw PWM value (0-4095)\n     */\n    export function setServoRawPWM(channel: number, pwmTicks: number) {\n        if (!initialized) init()\n        pwmTicks = Math.min(4095, Math.max(0, pwmTicks))\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set motor PWM for speed control\n     * @param channel PWM channel (0-15)\n     * @param speed speed value (-100 to 100, where 0 is stopped)\n     */\n    export function setMotorChannel(channel: number, speed: number) {\n        if (!initialized) init()\n\n        // Clamp speed to valid range\n        speed = Math.min(100, Math.max(-100, speed))\n\n        let centerPWM = 320\n        let rangePWM = 540 - 100\n        let halfRange = rangePWM / 2\n\n        let pwmTicks = Math.round(centerPWM + (speed / 100) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(540, Math.max(100, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Stop servo on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     */\n    export function stopServoChannel(channel: number) {\n        setPWM(channel, 0, 0)\n    }\n}\n\nconst SERVO_CHANNELS = [15, 14, 13, 12, 11, 10, 9, 8]\n\n/**\n * High-Level Servo Controller for DFR0548 Expansion Board\n * Maps servo ports S1-S8 to PCA9685 channels\n */\nnamespace ServoController {\n    /**\n     * Initialize the servo controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param angle Angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServo(servoPort: number, angle: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoChannel(channel, angle)\n    }\n\n    /**\n     * Stop servo by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     */\n    export function stopServo(servoPort: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.stopServoChannel(channel)\n    }\n\n    /**\n     * Set all servos to center position (0 degrees)\n     */\n    export function centerAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            setServo(i, 0)\n        }\n    }\n\n    /**\n     * Stop all servos\n     */\n    export function stopAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            stopServo(i)\n        }\n    }\n\n    /**\n     * Test all servos with a movement sequence\n     */\n    export function testAllServos(servos: number[]) {\n        for (let i = 0; i < servos.length; i++) {\n            let servoNum = servos[i]\n            setServo(servoNum, -90)\n            basic.pause(500)\n            setServo(servoNum, 90)\n            basic.pause(500)\n            setServo(servoNum, 0)\n        }\n    }\n\n    /**\n     * Set servo with custom PWM value for fine-tuning\n     */\n    export function setServoRawPWM(servoPort: number, pwmValue: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}\n\n/**\n * Motor Controller for DFR0548 Expansion Board\n * Controls DC motors through PWM speed control\n * Maps motor ports M1-M4 to PCA9685 channels 0-3\n */\nnamespace MotorController {\n\n    /**\n     * Initialize the motor controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param speed Angle in degrees (-100 to +100, where 0 is neutral)\n     */\n    export function setMotor(servoPort: number, speed: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setMotorChannel(channel, -speed)\n    }\n\n    /**\n     * Test all motors with a speed sequence\n     */\n    export function testAllMotors(motors: number[]) {\n        // Test each motor with different speeds\n        for (let i = 0; i < motors.length; i++) {\n            let motorNum = motors[i]\n\n            // Test 50% speed\n            setMotor(motorNum, 50)\n            basic.pause(200)\n\n            // Test 100% speed\n            setMotor(motorNum, 100)\n            basic.pause(200)\n\n            // Stop motor\n            setMotor(motorNum, 0)\n            basic.pause(500)\n\n            // Test -50% speed\n            setMotor(motorNum, -50)\n            basic.pause(200)\n\n            // Test -100% speed\n            setMotor(motorNum, -100)\n            basic.pause(200)\n\n            setMotor(motorNum, 0)\n        }\n        basic.pause(500)\n    }\n\n    /**\n     * Set motor with custom PWM value for fine-tuning\n     * @param motorPort Motor port number (1-4)\n     * @param pwmValue Raw PWM value (0-4095)\n     */\n    export function setMotorRawPWM(motorPort: number, pwmValue: number) {\n        if (motorPort < 1 || motorPort > 8) return\n\n        let channel = SERVO_CHANNELS[motorPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}// Add your code here\n","position.ts":"namespace position {\n\n    class OccupancyGrid {\n\n    }\n\n    export function updateSensors() {\n        //  Update Compass direction, current speed, deviation, commands coming from Bluetooth, ...\n        //  TO DO Compute current position with sensor fusion https://github.com/micropython-IMU/micropython-fusion/tree/master\n        let compass_heading = input.compassHeading()\n        let mag_x = input.magneticForce(Dimension.X)\n        let mag_y = input.magneticForce(Dimension.Y)\n        let mag_z = input.magneticForce(Dimension.Z)\n        let acc_x = input.acceleration(Dimension.X)\n        let acc_y = input.acceleration(Dimension.Y)\n        let acc_z = input.acceleration(Dimension.Z)\n        let acceleration = Math.sqrt(acc_x ** 2 + acc_y ** 2 + acc_z ** 2)\n    }\n\n    export function updateEnvironment() {\n        // re-compute the occupancy grid : QRCodes cardinals, home location, balls clusters, robots\n        // approximate the Robot orientation and position\n    }\n}","motion.ts":"namespace motion {\n\n    enum MotionDirection {\n        Idle,\n        Forward,\n        Backward,\n        Spinning\n    }\n\n    class Waypoint {\n        distance: number  //  mm\n        angle: number // radians\n        constructor(distance: number, angle: number) {\n            this.distance = distance\n            this.angle = angle\n        }\n    }\n\n    /*\n    ServoController.setServo(DIRECTION_SERVO, -45) //turn right\n    ServoController.setServo(DIRECTION_SERVO, 0) //straight\n    ServoController.setServo(DIRECTION_SERVO, 45) //turn left\n    MotorController.setMotor(SPEED_MOTOR, -100) //backward max speed\n    MotorController.setMotor(SPEED_MOTOR, 100) //forward max speed\n    */\n    export function goToWaypoint(waypoint: Waypoint) {\n        //  Drive servo and motor with PWM according to updated linear and angular velocities\n        //  Set the steering servo position to aim to the waypoint\n        let steering = 0\n        //  to be computed with PID\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P0.setAngle(steering)\n        } else {\n            ServoController.setServo(DIRECTION_SERVO, steering)\n        }\n\n        //  Set the servo throttle power depending on the remaining distance to the waypoint\n        let speed = 0\n        /*\n        // just for testing purpose\n        if (waypoint.distance > 60)\n            speed = 100\n        else if (waypoint.distance > 0)\n            speed = 50\n        */\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P1.run(speed)\n        } else {\n            MotorController.setMotor(SPEED_MOTOR, speed)\n        }\n\n    }\n\n}\n","vision.ts":"namespace vision_ns {\n\n    const HUSKY_SCREEN_WIDTH = 320; // pixels\n    const HUSKY_SCREEN_HEIGHT = 240; // pixels\n    const HUSKY_SCREEN_CENTER_X = HUSKY_SCREEN_WIDTH / 2;\n    const HUSKY_SCREEN_CENTER_Y = HUSKY_SCREEN_HEIGHT / 2;\n    const HUSKY_SCREEN_TOLERANCE_X = 10; // pixels\n\n    const BALL_REFERENCE_DISTANCE = 50; // (cm)\n    const BALL_REFERENCE_FRAMESIZE = 30; // (pixels) width and height of a ball frame at 50 cm distance\n    const BALL_DISTANCE_RATIO = BALL_REFERENCE_DISTANCE / BALL_REFERENCE_FRAMESIZE;\n\n    // Screen Side Class\n    export enum ScreenSide {\n        Left,\n        Right,\n        Middle\n    }\n\n    // QR Codes Configuration\n    const QR_CODES = [\n        { code: \"id300\", cardinal: \"East\", husky_learned_id: 1 },\n        { code: \"id301\", cardinal: \"South\", husky_learned_id: 2 },\n        { code: \"id302\", cardinal: \"West\", husky_learned_id: 3 },\n        { code: \"id303\", cardinal: \"North\", husky_learned_id: 4 },\n        { code: \"id407\", cardinal: \"Base\", husky_learned_id: 5 }\n    ];\n\n    // QR Code ID as recognized by Husky TagRecognition\n    export class QRcodeId {\n        static East = 1;\n        static South = 2;\n        static West = 3;\n        static North = 4;\n        static Base = 5;\n    }\n\n    // Object Color ID as recognized by Husky ColorRecognition\n    export class ObjectColorID {\n        static Red = 1; // a ball\n        static Yellow = 2; // another robot\n    }\n\n    // Object Class ID as recognized by Husky ObjectClassification\n    export class ObjectClassID {\n        static Unknown = 0;\n        static Ball = 1;\n        static Robot = 2;\n        static QRcode = 3;\n    }\n\n    // Object Kind\n    export enum ObjectKind {\n        Unknown,\n        Ball,\n        Robot,\n        QRcode\n    }\n\n\n    // Visual Object Class\n    export class VisualObject {\n        public x: number = -1\n        public y: number = -1\n        public w: number = -1\n        public h: number = -1\n        public id: number = -1 // ID as returned by Huskylens \n        public kind: ObjectKind = ObjectKind.Unknown\n        public last_seen: number = -1\n        public is_tracked: boolean = false\n        constructor() {\n        }\n\n        setCoordinates(x: number, y: number, w: number, h: number) {\n            // Set the object's coordinates and dimensions. Update LastSeen time.\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n            this.last_seen = input.runningTime();\n        }\n\n        reset() {\n            // Reset the object's coordinates and dimensions.\n            this.setCoordinates(0, 0, 0, 0);\n            this.last_seen = 0;\n        }\n\n        toString() {\n            // Display the object's details.\n            return `kind: ${this.kind} id: ${this.x} x:${this.x} y:${this.y} w:(${this.w} h:${this.h}`;\n        }\n\n        // Get side of the TrackedObject relative to the robot direction\n        getScreenSide() {\n            if (this.x > (HUSKY_SCREEN_CENTER_X + HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Right;\n            } else if (this.x < (HUSKY_SCREEN_CENTER_X - HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Left;\n            } else {\n                return ScreenSide.Middle;\n            }\n        }\n\n        // Compute distance of the TrackedObject based on the visual size ratio\n        getDistance() {\n            const size = Math.sqrt(this.w ** 2 + this.h ** 2); // frame diagonal\n            return (BALL_REFERENCE_FRAMESIZE * BALL_REFERENCE_DISTANCE) / size;\n        }\n\n        // Compute coordinates of the TrackedObject relative to the robot position (origin)\n        getAngle() {\n            const distance = this.getDistance();\n            const deltaX = Math.abs(this.x - HUSKY_SCREEN_CENTER_X);\n            const deltaY = Math.sqrt(distance ** 2 - deltaX ** 2);\n            // Angle between y front-axis and the ball projected coordinates(dx,dy)\n            return Math.atan2(deltaX, deltaY);\n        }\n    }\n\n    // Vision Processor Class\n    export class VisionProcessor {\n        public mode: number\n        public kind: number\n        public tracked: VisualObject\n        public codes: VisualObject[] = [];\n        public balls: VisualObject[] = [];\n        public bots: VisualObject[] = [];\n        public verbose: boolean = true\n        constructor(mode = protocolAlgorithm.ALGORITHM_TAG_RECOGNITION, kind = ObjectKind.QRcode) {\n            this.mode = mode;\n            this.kind = kind;\n            this.tracked = new VisualObject();\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n        }\n\n        setMode(mode: number) {\n            if (this.mode !== mode) {\n                this.mode = mode;\n                huskylens.initMode(this.mode);\n                if (this.verbose) { logger.log(`Mode set to: ${this.mode}`); }\n            }\n        }\n\n        setKind(kind: number) {\n            if (this.kind !== kind) {\n                this.kind = kind;\n                if (this.verbose) { logger.log(`Kind set to: ${this.kind}`); }\n            }\n        }\n\n        init() {\n            huskylens.initI2c();\n            huskylens.initMode(this.mode);\n        }\n\n        refreshForced(mode: number, kind: number) {\n            // Change temporarily the mode and the kind to refresh all objects once\n            const saveMode = this.mode;\n            const saveKind = this.kind;\n            this.setMode(mode);\n            this.setKind(kind);\n            this.refresh();\n            this.setMode(saveMode);\n            this.setKind(saveKind);\n        }\n\n        // Capture a new video frame and analyze it : is there 1 ball, no ball, a Tag, an obstacle or nothing ?\n        refresh() {\n            // Refresh the VisionProcessor.\n            huskylens.request();\n            if (this.verbose) { logger.log(`Husky (mode  ${this.mode}) captured IDs : ${huskylens.getIds()}`) }\n            if (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING) {\n                this.processSingleObject();\n            }\n            if ((this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING)) {\n                this.processAllObjects()\n            }\n        }\n\n        processSingleObject() {\n            // Process a single object in tracking mode.\n            // Frame (== Block type) appears in screen ?\n            this.tracked.is_tracked = huskylens.isAppear_s(HUSKYLENSResultType_t.HUSKYLENSResultBlock)\n            if (this.tracked.is_tracked) {\n                // check if the tracked object is a learnt object \n                if (!huskylens.isLearned(this.kind)) {\n                    if (this.verbose) { logger.log(\"Tracking UNKNOWN object\") }\n                }\n                const objectId = this.kind; // always one single TrackedObject in this mode\n                this.tracked.setCoordinates(\n                    huskylens.readeBox(objectId, Content1.xCenter),\n                    huskylens.readeBox(objectId, Content1.yCenter),\n                    huskylens.readeBox(objectId, Content1.width),\n                    huskylens.readeBox(objectId, Content1.height)\n                );\n                if (this.verbose) { logger.log(\"Tracked Object updated : \" + this.tracked.toString()) }\n\n            } else {\n                // if (input.runningTime() - trackedObject.lastSeen) > OBJECT_LOST_DELAY:\n                this.tracked.reset();\n                if (this.verbose) { logger.log(\"Tracked Object Lost\") }\n            }\n        }\n\n        processAllObjects() {\n            // Process all objects in recognition mode.\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n            // for each frame, Update the relative Position of the QR codes\n            const nbFrames = huskylens.getBox(HUSKYLENSResultType_t.HUSKYLENSResultBlock);\n            if (this.verbose) { logger.log(`Objects on screen : ${nbFrames}`); }\n            for (let i = 1; i <= nbFrames; i++) {\n                const vo = new VisualObject();\n                vo.id = huskylens.readBox_ss(i, Content3.ID);\n                vo.setCoordinates(\n                    huskylens.readBox_ss(i, Content3.xCenter),\n                    huskylens.readBox_ss(i, Content3.yCenter),\n                    huskylens.readBox_ss(i, Content3.width),\n                    huskylens.readBox_ss(i, Content3.height)\n                );\n\n                if (this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION) {\n                    vo.kind = ObjectKind.QRcode\n                    this.codes.push(vo);\n                    if (this.verbose) { logger.log(\"QR Tag found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION) {\n                    if (vo.id === ObjectColorID.Red) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectColorID.Yellow) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Colored object found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.OBJECTCLASSIFICATION) {\n                    if (vo.id === ObjectClassID.Ball) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.Robot) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.QRcode) {\n                        vo.kind = ObjectKind.QRcode\n                        this.codes.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Shaped object found : \" + vo.toString()); }\n                }\n            }\n        }\n    }\n\n}\n","game.ts":"enum GameMode {\n    Free, // Free running Robot until OBEY gets received\n    Slave, // Obey to Radio instructions\n}\nenum GameState {\n    Started,\n    Stopped,\n}\nclass BricksGame {\n    mode: GameMode = GameMode.Free\n    state: GameState = GameState.Stopped\n    startTime: number = -1;\n    constructor() {\n    }\n    public remainingTime(): number {\n        if (this.state == GameState.Started) {\n            return GAME_DURATION - (control.millis() - this.startTime) / 1000;\n        }\n        else return GAME_DURATION;// any positive number would be okay\n    }\n    public setState(state: GameState) {\n        if (this.state != state) {\n            this.state = state\n            logger.log(\"Robot State changed : \" + (\"\" + this.state))\n        }\n    }\n    public doObey() {\n        // Acknowledge the command\n        //UTBController.sendObeyMe()\n        this.mode = GameMode.Slave\n        basic.showIcon(IconNames.Angry)\n        music.setTempo(360)\n        music._playDefaultBackground(music.builtInPlayableMelody(Melodies.Funk), music.PlaybackMode.UntilDone)\n    }\n    public doStart() {\n        if (this.mode == GameMode.Slave) {\n            // Acknowledge the command\n            //UTBController.sendActionStart()\n            this.setState(GameState.Started)\n            this.startTime = control.millis()\n            //robot.doStart()\n            basic.showIcon(IconNames.Happy)\n            music.setTempo(360)\n            music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerUp), music.PlaybackMode.InBackground)\n        }\n        else {\n            logger.log(\"Asked to Start but not in Slave mode\");\n        }\n    }\n    public doStop() {\n        // Acknowledge the command\n        //UTBController.sendActionStop()\n        this.setState(GameState.Stopped)\n        //robot.doStop()\n        basic.showIcon(IconNames.Asleep)\n        music.setTempo(360)\n        music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerDown), music.PlaybackMode.InBackground)\n    }\n    public doDanger() {\n        // Acknowledge the command\n        //UTBController.sendActionDanger()\n        //robot.askGoingHome()\n        basic.showLeds(`\n            # # . # #\n            # # . # #\n            . . . . .\n            # # # # #\n            # # # # #\n            `)\n        basic.showIcon(IconNames.Surprised)\n        music.setTempo(360)\n        for (let index = 0; index < 4; index++) {\n            music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n        }\n    }\n}\n\n// Radio messages received from the controller\nfunction handleControllerDataReceived(receivedString: string) {\n\n}\n\nlet bricksGame = new BricksGame()\n\n// Button events\nfunction initButtonsEvents() {\n    input.onButtonPressed(Button.A, function () {\n        bricksGame.doStart()\n    })\n    input.onButtonPressed(Button.AB, function () {\n        bricksGame.doStop()\n    })\n    input.onLogoEvent(TouchButtonEvent.Pressed, function () {\n        bricksGame.doObey()\n    })\n    input.onButtonPressed(Button.B, function () {\n        bricksGame.doDanger()\n    })\n    // Logo Button Long Pressed to change the radio group\n    input.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n        //UTBRadio.showRadioGroup()\n        //UTBRadio.incrementRadioGroup()\n        //UTBRadio.showRadioGroup()\n    })\n}\n\n// Radio events\nserial.onDataReceived(serial.delimiters(Delimiters.NewLine), function () {\n    handleControllerDataReceived(serial.readLine())\n})\n\nfunction initGameController() {\n    //UTBController.initAsController()\n    //UTBRadio.showRadioGroup()\n}\n/*\n//source : https://github.com/Taccart/amaker-unleash-the-brick-example/blob/master/main.ts\nUnleashTheBricks.setLogLevel(LogLevel.Debug)\nUnleashTheBricks.setEchoToConsole(true)\nUnleashTheBricks.initCommunicationChannel(CommunicationChannel.Radio)\nUnleashTheBricks.setBotStatus(BotStatus.Searching)\nUnleashTheBricks.setBotStatus(BotStatus.Capturing)\nUnleashTheBricks.setBotStatus(BotStatus.BringingBack)\nbasic.forever(function () {\n    UnleashTheBricks.emitHeartBeat()\n    control.waitMicros(10000000)\n})\n*/","pxt.json":"{\n    \"name\": \"CybertruckJS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.7\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"logger.ts\",\n        \"controller.ts\",\n        \"position.ts\",\n        \"motion.ts\",\n        \"vision.ts\",\n        \"game.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1759760550347,"editorVersion":"8.0.16","text":{"main.ts":"// Timing Constants\r\nconst GAME_DURATION = 30; // seconds\r\nconst DELAY_TO_GO_HOME = 20; // seconds\r\nconst OBJECT_LOST_DELAY = 1; // second\r\n// Music constants :-)\r\nconst imperial_march = [\r\n    \"G4:6\", \"R:1\", \"G4:6\", \"R:1\", \"G4:6\",\r\n    \"D#4:6\", \"A#4:2\", \"G4:6\",\r\n    \"D#4:6\", \"A#4:2\", \"G4:6\"\r\n]\r\nconst windows_xp = [\r\n    \"D#5:3\", \"A#4:5\", \"G#4:6\",\r\n    \"D#5:3\", \"A#4:12\"\r\n]\r\nconst police = [\r\n    \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\"\r\n]\r\n// Parameters\r\nconst FOR_LATER_USE_SERVO = 1\r\nconst DIRECTION_SERVO = 2\r\nconst GRABBER_MOTOR = 3\r\nconst SPEED_MOTOR = 4\r\nconst HUSKY_WIRED = false; // true if the HuskyLens is wired with I2C\r\n\r\n// Execution Mode Parameters\r\nenum ExecMode {\r\n    MakeCode, // Offline software development with no attached board\r\n    FreeMode, // Free running Robot\r\n    GameMode, // Board wired with USB\r\n    WiredMode, // Board wired with USB\r\n}\r\n\r\n// Global Variables\r\nlet EXEC_MODE = ExecMode.MakeCode;\r\nlet cyclesCount = 0;\r\nlet initialized = false;\r\n\r\nlet bricksGame = new BricksGame();\r\nlet robot = new Robot()\r\nlet vision = new vision_ns.VisionProcessor(\r\n    protocolAlgorithm.ALGORITHM_TAG_RECOGNITION,\r\n    vision_ns.ObjectKind.QRcode\r\n);\r\nvision.verbose = false\r\n\r\n\r\nfunction init() {\r\n    // Initialization of the sensors, variables, display, callbacks\r\n    basic.clearScreen();\r\n    initButtonsEvents();\r\n    // Boot sequence\r\n    //music.setVolume(255)\r\n    //music.playMelody(imperial_march.join(\" \"), 150)\r\n    // Initialize servo controller\r\n    ServoController.init()\r\n    ServoController.centerAllServos()\r\n    ServoController.testAllServos([FOR_LATER_USE_SERVO, DIRECTION_SERVO])\r\n    MotorController.testAllMotors([GRABBER_MOTOR, SPEED_MOTOR])\r\n    logger.log(\"Expansion board health check completed\");\r\n    // Initialize physical sensors\r\n    if (EXEC_MODE != ExecMode.MakeCode) {\r\n        input.calibrateCompass()\r\n        input.setAccelerometerRange(AcceleratorRange.OneG)\r\n        logger.log(\"Calibration completed\");\r\n        if (HUSKY_WIRED) {\r\n            vision.init();\r\n            vision.refresh();\r\n            logger.log(\"Camera connected\");\r\n        }\r\n    }\r\n    // Disabled Bluetooth for the moment\r\n    // pxt build > error: conflict on yotta setting microbit-dal.bluetooth.enabled between extensions radio and bluetooth\r\n    //initBluetooth();\r\n    // Initialize Radio transmition with Game Server\r\n    if (EXEC_MODE == ExecMode.GameMode) {\r\n        initGameController();\r\n    }\r\n    initialized = true;\r\n    logger.log(\"Initialization completed\");\r\n\r\n}\r\ninit();\r\n\r\n\r\n// scheduled function calls\r\nfunction onEvery100ms() {\r\n    // Function called every 100ms\r\n}\r\n\r\nfunction onEvery200ms() {\r\n    //    send_telemetry();\r\n}\r\n\r\nfunction onEvery1s() {\r\n    // Function called every 500ms\r\n}\r\nfunction onEvery5s() {\r\n    logger.log(\"Remaining time \" + bricksGame.remainingTime())\r\n    logger.log(\"5s heartbeat\")\r\n    if (EXEC_MODE == ExecMode.GameMode) {\r\n        //UTBBot.emitHeartBeat() // from the rules of the game\r\n    }\r\n}\r\n\r\nloops.everyInterval(100, onEvery100ms);\r\nloops.everyInterval(200, onEvery200ms);\r\nloops.everyInterval(1000, onEvery1s);\r\nloops.everyInterval(5000, onEvery5s);\r\n\r\nfunction onForever() {\r\n    // Infinite loop (frequency = ?? Hz)\r\n    if (!initialized) { // https://support.microbit.org/support/solutions/articles/19000053084-forever-runs-before-onstart-finishes\r\n        return;\r\n    }\r\n    cyclesCount++;\r\n    vision.refresh();\r\n    position.updateSensors();\r\n    position.updateEnvironment();\r\n    robot.updateObjective();\r\n    robot.computeNextWaypoint();\r\n    motion.goToWaypoint(robot.waypoint);\r\n}\r\n\r\n// best effort loop\r\nbasic.forever(onForever);\r\n","README.md":"","logger.ts":"namespace logger {\n    /**\n     * Converts elapsed milliseconds to a formatted time string\n     * @param elapsedMs - The elapsed time in milliseconds\n     * @returns Formatted string in mm:ss:ms format\n     */\n    function formatElapsedTime(elapsedMs: number): string {\n        // Ensure non-negative value\n        const totalMs = Math.max(0, Math.floor(elapsedMs));\n        // Extract components\n        const minutes = Math.floor(totalMs / 60000);\n        const seconds = Math.floor((totalMs % 60000) / 1000);\n        const milliseconds = totalMs % 1000;\n        // Format with leading zeros using custom padding\n        const formattedMinutes = (minutes < 10 ? \"0\" : \"\") + minutes.toString();\n        const formattedSeconds = (seconds < 10 ? \"0\" : \"\") + seconds.toString();\n        const formattedMs = (milliseconds < 100 ? (milliseconds < 10 ? \"00\" : \"0\") : \"\") + milliseconds.toString();\n        return `${formattedMinutes}:${formattedSeconds}:${formattedMs}`;\n    }\n\n    function get_log_msg(logmsg: string): string {\n        return \"[\" + control.deviceName() + \"@\" + (\"\" + (\"\" + formatElapsedTime(control.millis()))) + \" (\" + cyclesCount + \")]\" + \" : \" + logmsg\n    }\n    // Logging function to Serial Monitor or Bluetooth\n    export function log(msg: string) {\n        msg = get_log_msg(msg);\n        switch (EXEC_MODE) {\n            case ExecMode.MakeCode:\n            case ExecMode.WiredMode:\n                serial.writeLine(msg);\n                //console.log(msg);\n                break;\n            case ExecMode.GameMode:\n            case ExecMode.FreeMode:\n                // disabled for the moment\n                //if (bluetooth_connected){ bluetooth.uartWriteLine(msg) }\n\n                // the radio channel is used for communication with the game controller\n                // so we cannot use it for logging\n                //radio.sendString(msg);\n                break;\n            default:\n                break;\n        }\n    }\n\n    export function send_telemetry() {\n        //  Log metrics and update Display\n        if (HUSKY_WIRED) {\n            //    huskylens.writeOSD(\"angle diff \"+str(steering_angle), 150, 30)\n            //    huskylens.writeOSD(\"servo_angle \"+str(servo_angle), 150, 60)\n            //    huskylens.writeOSD(\"input \"+str(steering_value), 150, 90)\n            huskylens.writeOSD(\"balls \" + (\"\" + vision.balls.length), 150, 120)\n        }\n\n        if ([ExecMode.MakeCode, ExecMode.WiredMode].indexOf(EXEC_MODE) >= 0) {\n            datalogger.log(datalogger.createCV(\"balls\", vision.balls.length))\n        }\n    }\n}","controller.ts":"/**\n * PCA9685 PWM Controller Abstraction Layer\n * Controls servos through I2C communication with the PCA9685 chip\n * \n * This module provides both low-level PCA9685 control and high-level servo control\n * for the DFR0548 micro:bit expansion board with 270-degree servos.\n */\n\n/**\n * Low-level PCA9685 PWM Controller\n */\nnamespace PCA9685 {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    let initialized = false\n\n    function i2cWrite(reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    function i2cRead(reg: number): number {\n        pins.i2cWriteNumber(PCA9685_ADDRESS, reg, NumberFormat.UInt8BE)\n        return pins.i2cReadNumber(PCA9685_ADDRESS, NumberFormat.UInt8BE)\n    }\n\n    function setPWM(channel: number, on: number, off: number) {\n        if (channel < 0 || channel > 15) return\n\n        let buf = pins.createBuffer(5)\n        buf[0] = LED0_ON_L + 4 * channel\n        buf[1] = on & 0xff\n        buf[2] = (on >> 8) & 0x0f\n        buf[3] = off & 0xff\n        buf[4] = (off >> 8) & 0x0f\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    export function init() {\n        if (initialized) return\n\n        // Reset PCA9685\n        i2cWrite(MODE1, 0x00)\n        basic.pause(10)\n\n        // Set PWM frequency to 50Hz (for servos)\n        setFrequency(50)\n\n        initialized = true\n    }\n\n    function setFrequency(freq: number) {\n        let prescaleval = 25000000    // 25MHz\n        prescaleval /= 4096           // 12-bit\n        prescaleval /= freq\n        prescaleval -= 1\n        let prescale = Math.floor(prescaleval + 0.5)\n\n        let oldmode = i2cRead(MODE1)\n        let newmode = (oldmode & 0x7F) | 0x10  // sleep\n        i2cWrite(MODE1, newmode)               // go to sleep\n        i2cWrite(PRESCALE, prescale)           // set prescaler\n        i2cWrite(MODE1, oldmode)\n        basic.pause(5)\n        i2cWrite(MODE1, oldmode | 0xa1)        // restart + auto increment\n    }\n\n    /**\n     * Set servo angle on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     * @param angle Servo angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServoChannel(channel: number, angle: number) {\n        if (!initialized) init()\n\n        // Clamp angle to valid range\n        angle = Math.min(90, Math.max(-90, angle))\n\n        // Use measured calibration values:\n        // -90° = 199 PWM, 0° = 333 PWM, +90° = 472 PWM\n        // Linear interpolation: PWM = center + (angle/90) * range\n        let centerPWM = 333\n        let rangePWM = 472 - 199  // Total range = 273 PWM ticks\n        let halfRange = rangePWM / 2  // 136.5 PWM ticks for ±90°\n\n        let pwmTicks = Math.round(centerPWM + (angle / 90) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(472, Math.max(199, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set servo with raw PWM ticks for calibration\n     * @param channel PWM channel (0-15)  \n     * @param pwmTicks Raw PWM value (0-4095)\n     */\n    export function setServoRawPWM(channel: number, pwmTicks: number) {\n        if (!initialized) init()\n        pwmTicks = Math.min(4095, Math.max(0, pwmTicks))\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set motor PWM for speed control\n     * @param channel PWM channel (0-15)\n     * @param speed speed value (-100 to 100, where 0 is stopped)\n     */\n    export function setMotorChannel(channel: number, speed: number) {\n        if (!initialized) init()\n\n        // Clamp speed to valid range\n        speed = Math.min(100, Math.max(-100, speed))\n\n        let centerPWM = 320\n        let rangePWM = 540 - 100\n        let halfRange = rangePWM / 2\n\n        let pwmTicks = Math.round(centerPWM + (speed / 100) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(540, Math.max(100, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Stop servo on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     */\n    export function stopServoChannel(channel: number) {\n        setPWM(channel, 0, 0)\n    }\n}\n\nconst SERVO_CHANNELS = [15, 14, 13, 12, 11, 10, 9, 8]\n\n/**\n * High-Level Servo Controller for DFR0548 Expansion Board\n * Maps servo ports S1-S8 to PCA9685 channels\n */\nnamespace ServoController {\n    /**\n     * Initialize the servo controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param angle Angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServo(servoPort: number, angle: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoChannel(channel, angle)\n    }\n\n    /**\n     * Stop servo by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     */\n    export function stopServo(servoPort: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.stopServoChannel(channel)\n    }\n\n    /**\n     * Set all servos to center position (0 degrees)\n     */\n    export function centerAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            setServo(i, 0)\n        }\n    }\n\n    /**\n     * Stop all servos\n     */\n    export function stopAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            stopServo(i)\n        }\n    }\n\n    /**\n     * Test all servos with a movement sequence\n     */\n    export function testAllServos(servos: number[]) {\n        for (let i = 0; i < servos.length; i++) {\n            let servoNum = servos[i]\n            setServo(servoNum, -90)\n            basic.pause(500)\n            setServo(servoNum, 90)\n            basic.pause(500)\n            setServo(servoNum, 0)\n        }\n    }\n\n    /**\n     * Set servo with custom PWM value for fine-tuning\n     */\n    export function setServoRawPWM(servoPort: number, pwmValue: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}\n\n/**\n * Motor Controller for DFR0548 Expansion Board\n * Controls DC motors through PWM speed control\n * Maps motor ports M1-M4 to PCA9685 channels 0-3\n */\nnamespace MotorController {\n\n    /**\n     * Initialize the motor controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param speed Angle in degrees (-100 to +100, where 0 is neutral)\n     */\n    export function setMotor(servoPort: number, speed: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setMotorChannel(channel, -speed)\n    }\n\n    /**\n     * Test all motors with a speed sequence\n     */\n    export function testAllMotors(motors: number[]) {\n        // Test each motor with different speeds\n        for (let i = 0; i < motors.length; i++) {\n            let motorNum = motors[i]\n\n            // Test 50% speed\n            setMotor(motorNum, 50)\n            basic.pause(200)\n\n            // Test 100% speed\n            setMotor(motorNum, 100)\n            basic.pause(200)\n\n            // Stop motor\n            setMotor(motorNum, 0)\n            basic.pause(500)\n\n            // Test -50% speed\n            setMotor(motorNum, -50)\n            basic.pause(200)\n\n            // Test -100% speed\n            setMotor(motorNum, -100)\n            basic.pause(200)\n\n            setMotor(motorNum, 0)\n        }\n        basic.pause(500)\n    }\n\n    /**\n     * Set motor with custom PWM value for fine-tuning\n     * @param motorPort Motor port number (1-4)\n     * @param pwmValue Raw PWM value (0-4095)\n     */\n    export function setMotorRawPWM(motorPort: number, pwmValue: number) {\n        if (motorPort < 1 || motorPort > 8) return\n\n        let channel = SERVO_CHANNELS[motorPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}// Add your code here\n","position.ts":"namespace position {\n\n    class OccupancyGrid {\n\n    }\n\n    export function updateSensors() {\n        //  Update Compass direction, current speed, deviation, commands coming from Bluetooth, ...\n        //  TO DO Compute current position with sensor fusion https://github.com/micropython-IMU/micropython-fusion/tree/master\n        let compass_heading = input.compassHeading()\n        let mag_x = input.magneticForce(Dimension.X)\n        let mag_y = input.magneticForce(Dimension.Y)\n        let mag_z = input.magneticForce(Dimension.Z)\n        let acc_x = input.acceleration(Dimension.X)\n        let acc_y = input.acceleration(Dimension.Y)\n        let acc_z = input.acceleration(Dimension.Z)\n        let acceleration = Math.sqrt(acc_x ** 2 + acc_y ** 2 + acc_z ** 2)\n    }\n\n    export function updateEnvironment() {\n        // re-compute the occupancy grid : QRCodes cardinals, home location, balls clusters, robots\n        // approximate the Robot orientation and position\n    }\n}","motion.ts":"namespace motion {\n\n    enum MotionDirection {\n        Idle,\n        Forward,\n        Backward,\n        Spinning\n    }\n\n    export class Waypoint {\n        distance: number  //  mm\n        angle: number // radians\n        constructor(distance: number, angle: number) {\n            this.distance = distance\n            this.angle = angle\n        }\n    }\n\n    /*\n    ServoController.setServo(DIRECTION_SERVO, -45) //turn right\n    ServoController.setServo(DIRECTION_SERVO, 0) //straight\n    ServoController.setServo(DIRECTION_SERVO, 45) //turn left\n    MotorController.setMotor(SPEED_MOTOR, -100) //backward max speed\n    MotorController.setMotor(SPEED_MOTOR, 100) //forward max speed\n    */\n    export function goToWaypoint(waypoint: Waypoint) {\n        //  Drive servo and motor with PWM according to updated linear and angular velocities\n        //  Set the steering servo position to aim to the waypoint\n        let steering = 0\n        //  to be computed with PID\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P0.setAngle(steering)\n        } else {\n            ServoController.setServo(DIRECTION_SERVO, steering)\n        }\n\n        //  Set the servo throttle power depending on the remaining distance to the waypoint\n        let speed = 0\n        /*\n        // just for testing purpose\n        if (waypoint.distance > 60)\n            speed = 100\n        else if (waypoint.distance > 0)\n            speed = 50\n        */\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P1.run(speed)\n        } else {\n            MotorController.setMotor(SPEED_MOTOR, speed)\n        }\n\n    }\n\n}\n","vision.ts":"namespace vision_ns {\n\n    const HUSKY_SCREEN_WIDTH = 320; // pixels\n    const HUSKY_SCREEN_HEIGHT = 240; // pixels\n    const HUSKY_SCREEN_CENTER_X = HUSKY_SCREEN_WIDTH / 2;\n    const HUSKY_SCREEN_CENTER_Y = HUSKY_SCREEN_HEIGHT / 2;\n    const HUSKY_SCREEN_TOLERANCE_X = 10; // pixels\n\n    const BALL_REFERENCE_DISTANCE = 50; // (cm)\n    const BALL_REFERENCE_FRAMESIZE = 30; // (pixels) width and height of a ball frame at 50 cm distance\n    const BALL_DISTANCE_RATIO = BALL_REFERENCE_DISTANCE / BALL_REFERENCE_FRAMESIZE;\n\n    // Screen Side Class\n    export enum ScreenSide {\n        Left,\n        Right,\n        Middle\n    }\n\n    // QR Codes Configuration\n    const QR_CODES = [\n        { code: \"id300\", cardinal: \"East\", husky_learned_id: 1 },\n        { code: \"id301\", cardinal: \"South\", husky_learned_id: 2 },\n        { code: \"id302\", cardinal: \"West\", husky_learned_id: 3 },\n        { code: \"id303\", cardinal: \"North\", husky_learned_id: 4 },\n        { code: \"id407\", cardinal: \"Base\", husky_learned_id: 5 }\n    ];\n\n    // QR Code ID as recognized by Husky TagRecognition\n    export class QRcodeId {\n        static East = 1;\n        static South = 2;\n        static West = 3;\n        static North = 4;\n        static Base = 5;\n    }\n\n    // Object Color ID as recognized by Husky ColorRecognition\n    export class ObjectColorID {\n        static Red = 1; // a ball\n        static Yellow = 2; // another robot\n    }\n\n    // Object Class ID as recognized by Husky ObjectClassification\n    export class ObjectClassID {\n        static Unknown = 0;\n        static Ball = 1;\n        static Robot = 2;\n        static QRcode = 3;\n    }\n\n    // Object Kind\n    export enum ObjectKind {\n        Unknown,\n        Ball,\n        Robot,\n        QRcode\n    }\n\n\n    // Visual Object Class\n    export class VisualObject {\n        public x: number = -1\n        public y: number = -1\n        public w: number = -1\n        public h: number = -1\n        public id: number = -1 // ID as returned by Huskylens \n        public kind: ObjectKind = ObjectKind.Unknown\n        public last_seen: number = -1\n        public is_tracked: boolean = false\n        constructor() {\n        }\n\n        setCoordinates(x: number, y: number, w: number, h: number) {\n            // Set the object's coordinates and dimensions. Update LastSeen time.\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n            this.last_seen = input.runningTime();\n        }\n\n        reset() {\n            // Reset the object's coordinates and dimensions.\n            this.setCoordinates(0, 0, 0, 0);\n            this.last_seen = 0;\n        }\n\n        toString() {\n            // Display the object's details.\n            return `kind: ${this.kind} id: ${this.x} x:${this.x} y:${this.y} w:(${this.w} h:${this.h}`;\n        }\n\n        // Get side of the TrackedObject relative to the robot direction\n        getScreenSide() {\n            if (this.x > (HUSKY_SCREEN_CENTER_X + HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Right;\n            } else if (this.x < (HUSKY_SCREEN_CENTER_X - HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Left;\n            } else {\n                return ScreenSide.Middle;\n            }\n        }\n\n        // Compute distance of the TrackedObject based on the visual size ratio\n        getDistance() {\n            const size = Math.sqrt(this.w ** 2 + this.h ** 2); // frame diagonal\n            return (BALL_REFERENCE_FRAMESIZE * BALL_REFERENCE_DISTANCE) / size;\n        }\n\n        // Compute coordinates of the TrackedObject relative to the robot position (origin)\n        getAngle() {\n            const distance = this.getDistance();\n            const deltaX = Math.abs(this.x - HUSKY_SCREEN_CENTER_X);\n            const deltaY = Math.sqrt(distance ** 2 - deltaX ** 2);\n            // Angle between y front-axis and the ball projected coordinates(dx,dy)\n            return Math.atan2(deltaX, deltaY);\n        }\n    }\n\n    // Vision Processor Class\n    export class VisionProcessor {\n        public mode: number\n        public kind: number\n        public tracked: VisualObject\n        public codes: VisualObject[] = [];\n        public balls: VisualObject[] = [];\n        public bots: VisualObject[] = [];\n        public verbose: boolean = true\n        constructor(mode = protocolAlgorithm.ALGORITHM_TAG_RECOGNITION, kind = ObjectKind.QRcode) {\n            this.mode = mode;\n            this.kind = kind;\n            this.tracked = new VisualObject();\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n        }\n\n        setMode(mode: number) {\n            if (this.mode !== mode) {\n                this.mode = mode;\n                huskylens.initMode(this.mode);\n                if (this.verbose) { logger.log(`Mode set to: ${this.mode}`); }\n            }\n        }\n\n        setKind(kind: number) {\n            if (this.kind !== kind) {\n                this.kind = kind;\n                if (this.verbose) { logger.log(`Kind set to: ${this.kind}`); }\n            }\n        }\n\n        init() {\n            huskylens.initI2c();\n            huskylens.initMode(this.mode);\n        }\n\n        refreshForced(mode: number, kind: number) {\n            // Change temporarily the mode and the kind to refresh all objects once\n            const saveMode = this.mode;\n            const saveKind = this.kind;\n            this.setMode(mode);\n            this.setKind(kind);\n            this.refresh();\n            this.setMode(saveMode);\n            this.setKind(saveKind);\n        }\n\n        // Capture a new video frame and analyze it : is there 1 ball, no ball, a Tag, an obstacle or nothing ?\n        refresh() {\n            // Refresh the VisionProcessor.\n            huskylens.request();\n            if (this.verbose) { logger.log(`Husky (mode  ${this.mode}) captured IDs : ${huskylens.getIds()}`) }\n            if (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING) {\n                this.processSingleObject();\n            }\n            if ((this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING)) {\n                this.processAllObjects()\n            }\n        }\n\n        processSingleObject() {\n            // Process a single object in tracking mode.\n            // Frame (== Block type) appears in screen ?\n            this.tracked.is_tracked = huskylens.isAppear_s(HUSKYLENSResultType_t.HUSKYLENSResultBlock)\n            if (this.tracked.is_tracked) {\n                // check if the tracked object is a learnt object \n                if (!huskylens.isLearned(this.kind)) {\n                    if (this.verbose) { logger.log(\"Tracking UNKNOWN object\") }\n                }\n                const objectId = this.kind; // always one single TrackedObject in this mode\n                this.tracked.setCoordinates(\n                    huskylens.readeBox(objectId, Content1.xCenter),\n                    huskylens.readeBox(objectId, Content1.yCenter),\n                    huskylens.readeBox(objectId, Content1.width),\n                    huskylens.readeBox(objectId, Content1.height)\n                );\n                if (this.verbose) { logger.log(\"Tracked Object updated : \" + this.tracked.toString()) }\n\n            } else {\n                // if (input.runningTime() - trackedObject.lastSeen) > OBJECT_LOST_DELAY:\n                this.tracked.reset();\n                if (this.verbose) { logger.log(\"Tracked Object Lost\") }\n            }\n        }\n\n        processAllObjects() {\n            // Process all objects in recognition mode.\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n            // for each frame, Update the relative Position of the QR codes\n            const nbFrames = huskylens.getBox(HUSKYLENSResultType_t.HUSKYLENSResultBlock);\n            if (this.verbose) { logger.log(`Objects on screen : ${nbFrames}`); }\n            for (let i = 1; i <= nbFrames; i++) {\n                const vo = new VisualObject();\n                vo.id = huskylens.readBox_ss(i, Content3.ID);\n                vo.setCoordinates(\n                    huskylens.readBox_ss(i, Content3.xCenter),\n                    huskylens.readBox_ss(i, Content3.yCenter),\n                    huskylens.readBox_ss(i, Content3.width),\n                    huskylens.readBox_ss(i, Content3.height)\n                );\n\n                if (this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION) {\n                    vo.kind = ObjectKind.QRcode\n                    this.codes.push(vo);\n                    if (this.verbose) { logger.log(\"QR Tag found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION) {\n                    if (vo.id === ObjectColorID.Red) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectColorID.Yellow) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Colored object found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.OBJECTCLASSIFICATION) {\n                    if (vo.id === ObjectClassID.Ball) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.Robot) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.QRcode) {\n                        vo.kind = ObjectKind.QRcode\n                        this.codes.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Shaped object found : \" + vo.toString()); }\n                }\n            }\n        }\n    }\n\n}\n","game.ts":"enum GameMode {\n    Free, // Free running Robot until OBEY gets received\n    Slave, // Obey to Radio instructions\n}\nenum GameState {\n    Started,\n    Stopped,\n}\nclass BricksGame {\n    mode: GameMode = GameMode.Free\n    state: GameState = GameState.Stopped\n    startTime: number = -1;\n    constructor() {\n    }\n    public remainingTime(): number {\n        if (this.state == GameState.Started) {\n            return GAME_DURATION - (control.millis() - this.startTime) / 1000;\n        }\n        else return GAME_DURATION;// any positive number would be okay\n    }\n    public setState(state: GameState) {\n        if (this.state != state) {\n            this.state = state\n            logger.log(\"Robot State changed : \" + (\"\" + this.state))\n        }\n    }\n    public doObey() {\n        // Acknowledge the command\n        //UTBController.sendObeyMe()\n        this.mode = GameMode.Slave\n        basic.showIcon(IconNames.Angry)\n        //music.setTempo(360)\n        //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.Funk), music.PlaybackMode.UntilDone)\n        logger.log(\"Robot in Slave mode\");\n    }\n    public doStart() {\n        if (this.mode == GameMode.Slave) {\n            // Acknowledge the command\n            //UTBController.sendActionStart()\n            this.setState(GameState.Started)\n            this.startTime = control.millis()\n            robot.doStart()\n            basic.showIcon(IconNames.Happy)\n            //music.setTempo(360)\n            //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerUp), music.PlaybackMode.InBackground)\n        }\n        else {\n            logger.log(\"Asked to Start but not in Slave mode\");\n        }\n    }\n    public doStop() {\n        // Acknowledge the command\n        //UTBController.sendActionStop()\n        this.setState(GameState.Stopped)\n        robot.doStop()\n        basic.showIcon(IconNames.Asleep)\n        //music.setTempo(360)\n        //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerDown), music.PlaybackMode.InBackground)\n    }\n    public doDanger() {\n        // Acknowledge the command\n        //UTBController.sendActionDanger()\n        robot.askGoingHome()\n        basic.showLeds(`\n            # # . # #\n            # # . # #\n            . . . . .\n            # # # # #\n            # # # # #\n            `)\n        basic.showIcon(IconNames.Surprised)\n        //music.setTempo(360)\n        //for (let index = 0; index < 4; index++) {\n        //    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n       // }\n    }\n}\n\n// Radio messages received from the controller\nfunction handleControllerDataReceived(receivedString: string) {\n\n}\n\n\n// Button events\nfunction initButtonsEvents() {\n    input.onButtonPressed(Button.A, function () {\n        bricksGame.doStart()\n    })\n    input.onButtonPressed(Button.AB, function () {\n        bricksGame.doStop()\n    })\n    input.onLogoEvent(TouchButtonEvent.Pressed, function () {\n        bricksGame.doObey()\n    })\n    input.onButtonPressed(Button.B, function () {\n        bricksGame.doDanger()\n    })\n    // Logo Button Long Pressed to change the radio group\n    input.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n        //UTBRadio.showRadioGroup()\n        //UTBRadio.incrementRadioGroup()\n        //UTBRadio.showRadioGroup()\n    })\n}\n\n// Radio events\nserial.onDataReceived(serial.delimiters(Delimiters.NewLine), function () {\n    handleControllerDataReceived(serial.readLine())\n})\n\nfunction initGameController() {\n    //UTBController.initAsController()\n    //UTBRadio.showRadioGroup()\n}\n/*\n//source : https://github.com/Taccart/amaker-unleash-the-brick-example/blob/master/main.ts\nUnleashTheBricks.setLogLevel(LogLevel.Debug)\nUnleashTheBricks.setEchoToConsole(true)\nUnleashTheBricks.initCommunicationChannel(CommunicationChannel.Radio)\nUnleashTheBricks.setBotStatus(BotStatus.Searching)\nUnleashTheBricks.setBotStatus(BotStatus.Capturing)\nUnleashTheBricks.setBotStatus(BotStatus.BringingBack)\nbasic.forever(function () {\n    UnleashTheBricks.emitHeartBeat()\n    control.waitMicros(10000000)\n})\n*/","robot.ts":"enum RobotState {\n    stopped,       //Game.State == Stopped\n    waiting,       //Game.State == Stopped, Game.Mode == Slave\n    searchingBalls,//Game.State == Started\n    trackingBall,  //Game.State == Started\n    searchingHome, //Game.State == Started\n    goingHome,     //Game.State == Started\n    atHome // when at home, send status  <name>:<timer> mission:safe_place_reached, wait 5s then resume\n}\n\n\nclass Robot {\n    state: number\n    waypoint: motion.Waypoint\n    constructor() {\n        this.state = RobotState.waiting\n    }\n\n    public setState(state: number) {\n        if (this.state != state) {\n            this.state = state\n            logger.log(\"Robot State changed : \" + this.state)\n            switch (this.state) {\n                case RobotState.stopped:\n                case RobotState.atHome:\n                case RobotState.searchingBalls:\n                case RobotState.searchingHome:\n                case RobotState.trackingBall:\n                case RobotState.goingHome:\n                    break\n                default:\n                    break\n            }\n        }\n\n    }\n\n    // Externel explicit state changes\n    public doStart() {\n        logger.log(\"Game started at \" + bricksGame.startTime + \" . Starting collecting balls...\")\n        MotorController.setMotor(GRABBER_MOTOR, -50) //grab\n        this.setState(RobotState.searchingBalls)\n    }\n    public doStop() {\n        logger.log(\"Game Stopped. Stopping collecting balls.\")\n        MotorController.setMotor(GRABBER_MOTOR, 0) //stop grabbing\n        this.setState(RobotState.stopped)\n    }\n    public askGoingHome() {\n        logger.log(\"Should I go home ?\")\n        //we can decide to ignore or not the instruction from Game controller\n    }\n    public doGoHome() {\n        logger.log(\"Going home. If location unknown, look for it.\")\n        // no more balls, or time is over, or acknolewdging danger mode\n        this.setState(RobotState.searchingHome)\n    }\n\n    // Autonomous decision making\n    public updateObjective() {\n        //  Based on input signals, current position, object recgnition and game instructions\n        //  determine the next action and next state\n        // \n        //  Condition 1 : get closer to the home before the end of the game\n        //  (TO DO : consider distance_to_home)\n        //logger.log(\"Remaining time \" + bricksGame.remainingTime())\n        if ((bricksGame.remainingTime() < DELAY_TO_GO_HOME)\n            && (this.state != RobotState.searchingHome)\n            && (this.state != RobotState.goingHome)\n            && (this.state != RobotState.atHome)) {\n            logger.log(\"########### GO HOME ###################\")\n            this.doGoHome()\n        }\n        if (bricksGame.remainingTime() < 0) {\n            logger.log(\"########### STOP  ###################\")\n            this.doStop()\n        }\n        // While waiting for the game to start\n        // we could also spin left/right and look at the balls and QR Codes\n        if (this.state == RobotState.searchingBalls) {\n            if (vision.balls.length > 0) {\n                logger.log(\"Found Balls on screen : \" + vision.balls.length)\n                this.setState(RobotState.trackingBall)\n                // TO DO define waypoint to the closest or the most centered ball\n            }\n            else {\n                logger.log(\"Keep searching...\")\n                // TO DO we need to spin randomly or to head to the latest know ball location\n            }\n        }\n        if (this.state == RobotState.trackingBall) {\n            if (vision.balls.length == 0) {\n                logger.log(\"Previous ball LOST or COLLECTED. Back to searching...(on screen Balls: \" + vision.balls.length + \")\")\n                this.setState(RobotState.searchingBalls)\n            }\n            else {\n                logger.log(\"Tracking the closest ball... (on screen Balls: \" + vision.balls.length + \")\")\n                // TO DO update waypoint to the closest or the most centered ball\n            }\n        }\n\n\n        //  Condition 2 : ...\n\n        //  Condition 3 : ...\n\n    }\n\n    // Motion decision\n    public computeNextWaypoint() {\n        // Based on the Robot State, Goal and Environment\n        // Determine the next waypoint to reach, and linear and angular velocities to reach it\n        // if tracking a VisualObject : compute the angle compared to screen center\n        // if heading blindly to a direction : compute the angle compared to compass orientation\n        // if explicit movement (spinRight, spinLeft, ...) : use the compass too\n        switch (this.state) {\n            case RobotState.stopped:\n            case RobotState.atHome:\n                this.waypoint.distance = 0\n                this.waypoint.angle = 0\n                break\n            case RobotState.searchingBalls:\n                // we are likely spinning around\n                break\n            case RobotState.searchingHome:\n                // we are likely spinning around\n                break\n            case RobotState.trackingBall:\n                // waypoint == closest ball on Camera\n                break\n            case RobotState.goingHome:\n                // waypoint == QRCode on Camera\n                break\n            default:\n                break\n        }\n    }\n}","pxt.json":"{\n    \"name\": \"CybertruckJS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.7\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"logger.ts\",\n        \"controller.ts\",\n        \"position.ts\",\n        \"motion.ts\",\n        \"vision.ts\",\n        \"game.ts\",\n        \"robot.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}},{"timestamp":1759763039378,"editorVersion":"8.0.16","text":{"main.ts":"// Timing Constants\r\nconst GAME_DURATION = 30; // seconds\r\nconst DELAY_TO_GO_HOME = 20; // seconds\r\nconst OBJECT_LOST_DELAY = 1; // second\r\n// Music constants :-)\r\nconst imperial_march = [\r\n    \"G4:6\", \"R:1\", \"G4:6\", \"R:1\", \"G4:6\",\r\n    \"D#4:6\", \"A#4:2\", \"G4:6\",\r\n    \"D#4:6\", \"A#4:2\", \"G4:6\"\r\n]\r\nconst windows_xp = [\r\n    \"D#5:3\", \"A#4:5\", \"G#4:6\",\r\n    \"D#5:3\", \"A#4:12\"\r\n]\r\nconst police = [\r\n    \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\", \"A5:4\", \"D5:4\"\r\n]\r\n// Parameters\r\nconst FOR_LATER_USE_SERVO = 1\r\nconst DIRECTION_SERVO = 2\r\nconst GRABBER_MOTOR = 3\r\nconst SPEED_MOTOR = 4\r\nconst HUSKY_WIRED = false; // true if the HuskyLens is wired with I2C\r\n\r\n// Execution Mode Parameters\r\nenum ExecMode {\r\n    MakeCode, // Offline software development with no attached board\r\n    FreeMode, // Free running Robot\r\n    GameMode, // Board wired with USB\r\n    WiredMode, // Board wired with USB\r\n}\r\n\r\n// Global Variables\r\nlet EXEC_MODE = ExecMode.MakeCode;\r\nlet cyclesCount = 0;\r\nlet initialized = false;\r\n\r\nlet bricksGame = new BricksGame();\r\nlet robot = new Robot()\r\nlet vision = new vision_ns.VisionProcessor(\r\n    protocolAlgorithm.ALGORITHM_TAG_RECOGNITION,\r\n    vision_ns.ObjectKind.QRcode\r\n);\r\nvision.verbose = false\r\n\r\n\r\nfunction init() {\r\n    // Initialization of the sensors, variables, display, callbacks\r\n    basic.clearScreen();\r\n    initButtonsEvents();\r\n    // Boot sequence\r\n    //music.setVolume(255)\r\n    //music.playMelody(imperial_march.join(\" \"), 150)\r\n    // Initialize servo controller\r\n    ServoController.init()\r\n    ServoController.centerAllServos()\r\n    ServoController.testAllServos([FOR_LATER_USE_SERVO, DIRECTION_SERVO])\r\n    MotorController.testAllMotors([GRABBER_MOTOR, SPEED_MOTOR])\r\n    logger.log(\"Expansion board health check completed\");\r\n    // Initialize physical sensors\r\n    if (EXEC_MODE != ExecMode.MakeCode) {\r\n        input.calibrateCompass()\r\n        input.setAccelerometerRange(AcceleratorRange.OneG)\r\n        logger.log(\"Calibration completed\");\r\n        if (HUSKY_WIRED) {\r\n            vision.init();\r\n            vision.refresh();\r\n            logger.log(\"Camera connected\");\r\n        }\r\n    }\r\n    // Disabled Bluetooth for the moment\r\n    // pxt build > error: conflict on yotta setting microbit-dal.bluetooth.enabled between extensions radio and bluetooth\r\n    //initBluetooth();\r\n    // Initialize Radio transmition with Game Server\r\n    if (EXEC_MODE == ExecMode.GameMode) {\r\n        initGameController();\r\n    }\r\n    initialized = true;\r\n    logger.log(\"Initialization completed\");\r\n\r\n}\r\ninit();\r\n\r\n\r\n// scheduled function calls\r\nfunction onEvery100ms() {\r\n    // Function called every 100ms\r\n}\r\n\r\nfunction onEvery200ms() {\r\n    //    send_telemetry();\r\n}\r\n\r\nfunction onEvery1s() {\r\n    // Function called every 500ms\r\n}\r\nfunction onEvery5s() {\r\n    logger.log(\"Remaining time \" + bricksGame.remainingTime())\r\n    logger.log(\"5s heartbeat\")\r\n    if (EXEC_MODE == ExecMode.GameMode) {\r\n        //UTBBot.emitHeartBeat() // from the rules of the game\r\n    }\r\n}\r\n\r\nloops.everyInterval(100, onEvery100ms);\r\nloops.everyInterval(200, onEvery200ms);\r\nloops.everyInterval(1000, onEvery1s);\r\nloops.everyInterval(5000, onEvery5s);\r\n\r\nfunction onForever() {\r\n    // Infinite loop (frequency = ?? Hz)\r\n    if (!initialized) { // https://support.microbit.org/support/solutions/articles/19000053084-forever-runs-before-onstart-finishes\r\n        return;\r\n    }\r\n    cyclesCount++;\r\n    vision.refresh();\r\n    position.updateSensors();\r\n    position.updateEnvironment();\r\n    robot.updateObjective();\r\n    robot.computeNextWaypoint();\r\n    motion.goToWaypoint();\r\n}\r\n\r\n// best effort loop\r\nbasic.forever(onForever);\r\n","README.md":"","logger.ts":"namespace logger {\n    /**\n     * Converts elapsed milliseconds to a formatted time string\n     * @param elapsedMs - The elapsed time in milliseconds\n     * @returns Formatted string in mm:ss:ms format\n     */\n    function formatElapsedTime(elapsedMs: number): string {\n        // Ensure non-negative value\n        const totalMs = Math.max(0, Math.floor(elapsedMs));\n        // Extract components\n        const minutes = Math.floor(totalMs / 60000);\n        const seconds = Math.floor((totalMs % 60000) / 1000);\n        const milliseconds = totalMs % 1000;\n        // Format with leading zeros using custom padding\n        const formattedMinutes = (minutes < 10 ? \"0\" : \"\") + minutes.toString();\n        const formattedSeconds = (seconds < 10 ? \"0\" : \"\") + seconds.toString();\n        const formattedMs = (milliseconds < 100 ? (milliseconds < 10 ? \"00\" : \"0\") : \"\") + milliseconds.toString();\n        return `${formattedMinutes}:${formattedSeconds}:${formattedMs}`;\n    }\n\n    function get_log_msg(logmsg: string): string {\n        return \"[\" + control.deviceName() + \"@\" + (\"\" + (\"\" + formatElapsedTime(control.millis()))) + \" (\" + cyclesCount + \")]\" + \" : \" + logmsg\n    }\n    // Logging function to Serial Monitor or Bluetooth\n    export function log(msg: string) {\n        msg = get_log_msg(msg);\n        switch (EXEC_MODE) {\n            case ExecMode.MakeCode:\n            case ExecMode.WiredMode:\n                serial.writeLine(msg);\n                //console.log(msg);\n                break;\n            case ExecMode.GameMode:\n            case ExecMode.FreeMode:\n                // disabled for the moment\n                //if (bluetooth_connected){ bluetooth.uartWriteLine(msg) }\n\n                // the radio channel is used for communication with the game controller\n                // so we cannot use it for logging\n                //radio.sendString(msg);\n                break;\n            default:\n                break;\n        }\n    }\n\n    export function send_telemetry() {\n        //  Log metrics and update Display\n        if (HUSKY_WIRED) {\n            //    huskylens.writeOSD(\"angle diff \"+str(steering_angle), 150, 30)\n            //    huskylens.writeOSD(\"servo_angle \"+str(servo_angle), 150, 60)\n            //    huskylens.writeOSD(\"input \"+str(steering_value), 150, 90)\n            huskylens.writeOSD(\"balls \" + (\"\" + vision.balls.length), 150, 120)\n        }\n\n        if ([ExecMode.MakeCode, ExecMode.WiredMode].indexOf(EXEC_MODE) >= 0) {\n            datalogger.log(datalogger.createCV(\"balls\", vision.balls.length))\n        }\n    }\n}","controller.ts":"/**\n * PCA9685 PWM Controller Abstraction Layer\n * Controls servos through I2C communication with the PCA9685 chip\n * \n * This module provides both low-level PCA9685 control and high-level servo control\n * for the DFR0548 micro:bit expansion board with 270-degree servos.\n */\n\n/**\n * Low-level PCA9685 PWM Controller\n */\nnamespace PCA9685 {\n    const PCA9685_ADDRESS = 0x40\n    const MODE1 = 0x00\n    const PRESCALE = 0xFE\n    const LED0_ON_L = 0x06\n\n    let initialized = false\n\n    function i2cWrite(reg: number, value: number) {\n        let buf = pins.createBuffer(2)\n        buf[0] = reg\n        buf[1] = value\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    function i2cRead(reg: number): number {\n        pins.i2cWriteNumber(PCA9685_ADDRESS, reg, NumberFormat.UInt8BE)\n        return pins.i2cReadNumber(PCA9685_ADDRESS, NumberFormat.UInt8BE)\n    }\n\n    function setPWM(channel: number, on: number, off: number) {\n        if (channel < 0 || channel > 15) return\n\n        let buf = pins.createBuffer(5)\n        buf[0] = LED0_ON_L + 4 * channel\n        buf[1] = on & 0xff\n        buf[2] = (on >> 8) & 0x0f\n        buf[3] = off & 0xff\n        buf[4] = (off >> 8) & 0x0f\n        pins.i2cWriteBuffer(PCA9685_ADDRESS, buf)\n    }\n\n    export function init() {\n        if (initialized) return\n\n        // Reset PCA9685\n        i2cWrite(MODE1, 0x00)\n        basic.pause(10)\n\n        // Set PWM frequency to 50Hz (for servos)\n        setFrequency(50)\n\n        initialized = true\n    }\n\n    function setFrequency(freq: number) {\n        let prescaleval = 25000000    // 25MHz\n        prescaleval /= 4096           // 12-bit\n        prescaleval /= freq\n        prescaleval -= 1\n        let prescale = Math.floor(prescaleval + 0.5)\n\n        let oldmode = i2cRead(MODE1)\n        let newmode = (oldmode & 0x7F) | 0x10  // sleep\n        i2cWrite(MODE1, newmode)               // go to sleep\n        i2cWrite(PRESCALE, prescale)           // set prescaler\n        i2cWrite(MODE1, oldmode)\n        basic.pause(5)\n        i2cWrite(MODE1, oldmode | 0xa1)        // restart + auto increment\n    }\n\n    /**\n     * Set servo angle on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     * @param angle Servo angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServoChannel(channel: number, angle: number) {\n        if (!initialized) init()\n\n        // Clamp angle to valid range\n        angle = Math.min(90, Math.max(-90, angle))\n\n        // Use measured calibration values:\n        // -90° = 199 PWM, 0° = 333 PWM, +90° = 472 PWM\n        // Linear interpolation: PWM = center + (angle/90) * range\n        let centerPWM = 333\n        let rangePWM = 472 - 199  // Total range = 273 PWM ticks\n        let halfRange = rangePWM / 2  // 136.5 PWM ticks for ±90°\n\n        let pwmTicks = Math.round(centerPWM + (angle / 90) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(472, Math.max(199, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set servo with raw PWM ticks for calibration\n     * @param channel PWM channel (0-15)  \n     * @param pwmTicks Raw PWM value (0-4095)\n     */\n    export function setServoRawPWM(channel: number, pwmTicks: number) {\n        if (!initialized) init()\n        pwmTicks = Math.min(4095, Math.max(0, pwmTicks))\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Set motor PWM for speed control\n     * @param channel PWM channel (0-15)\n     * @param speed speed value (-100 to 100, where 0 is stopped)\n     */\n    export function setMotorChannel(channel: number, speed: number) {\n        if (!initialized) init()\n\n        // Clamp speed to valid range\n        speed = Math.min(100, Math.max(-100, speed))\n\n        let centerPWM = 320\n        let rangePWM = 540 - 100\n        let halfRange = rangePWM / 2\n\n        let pwmTicks = Math.round(centerPWM + (speed / 100) * halfRange)\n\n        // Safety clamp to measured range\n        pwmTicks = Math.min(540, Math.max(100, pwmTicks))\n\n        setPWM(channel, 0, pwmTicks)\n    }\n\n    /**\n     * Stop servo on specific PCA9685 channel\n     * @param channel PWM channel (0-15)\n     */\n    export function stopServoChannel(channel: number) {\n        setPWM(channel, 0, 0)\n    }\n}\n\nconst SERVO_CHANNELS = [15, 14, 13, 12, 11, 10, 9, 8]\n\n/**\n * High-Level Servo Controller for DFR0548 Expansion Board\n * Maps servo ports S1-S8 to PCA9685 channels\n */\nnamespace ServoController {\n    /**\n     * Initialize the servo controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param angle Angle in degrees (-90 to +90, where 0 is center)\n     */\n    export function setServo(servoPort: number, angle: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoChannel(channel, angle)\n    }\n\n    /**\n     * Stop servo by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     */\n    export function stopServo(servoPort: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.stopServoChannel(channel)\n    }\n\n    /**\n     * Set all servos to center position (0 degrees)\n     */\n    export function centerAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            setServo(i, 0)\n        }\n    }\n\n    /**\n     * Stop all servos\n     */\n    export function stopAllServos() {\n        for (let i = 1; i <= 8; i++) {\n            stopServo(i)\n        }\n    }\n\n    /**\n     * Test all servos with a movement sequence\n     */\n    export function testAllServos(servos: number[]) {\n        for (let i = 0; i < servos.length; i++) {\n            let servoNum = servos[i]\n            setServo(servoNum, -90)\n            basic.pause(500)\n            setServo(servoNum, 90)\n            basic.pause(500)\n            setServo(servoNum, 0)\n        }\n    }\n\n    /**\n     * Set servo with custom PWM value for fine-tuning\n     */\n    export function setServoRawPWM(servoPort: number, pwmValue: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}\n\n/**\n * Motor Controller for DFR0548 Expansion Board\n * Controls DC motors through PWM speed control\n * Maps motor ports M1-M4 to PCA9685 channels 0-3\n */\nnamespace MotorController {\n\n    /**\n     * Initialize the motor controller\n     */\n    export function init() {\n        PCA9685.init()\n    }\n\n    /**\n     * Set servo position by servo port number\n     * @param servoPort Servo port number (1-8 on the expansion board)\n     * @param speed Angle in degrees (-100 to +100, where 0 is neutral)\n     */\n    export function setMotor(servoPort: number, speed: number) {\n        if (servoPort < 1 || servoPort > 8) return\n\n        let channel = SERVO_CHANNELS[servoPort - 1]\n        PCA9685.setMotorChannel(channel, -speed)\n    }\n\n    /**\n     * Test all motors with a speed sequence\n     */\n    export function testAllMotors(motors: number[]) {\n        // Test each motor with different speeds\n        for (let i = 0; i < motors.length; i++) {\n            let motorNum = motors[i]\n\n            // Test 50% speed\n            setMotor(motorNum, 50)\n            basic.pause(200)\n\n            // Test 100% speed\n            setMotor(motorNum, 100)\n            basic.pause(200)\n\n            // Stop motor\n            setMotor(motorNum, 0)\n            basic.pause(500)\n\n            // Test -50% speed\n            setMotor(motorNum, -50)\n            basic.pause(200)\n\n            // Test -100% speed\n            setMotor(motorNum, -100)\n            basic.pause(200)\n\n            setMotor(motorNum, 0)\n        }\n        basic.pause(500)\n    }\n\n    /**\n     * Set motor with custom PWM value for fine-tuning\n     * @param motorPort Motor port number (1-4)\n     * @param pwmValue Raw PWM value (0-4095)\n     */\n    export function setMotorRawPWM(motorPort: number, pwmValue: number) {\n        if (motorPort < 1 || motorPort > 8) return\n\n        let channel = SERVO_CHANNELS[motorPort - 1]\n        PCA9685.setServoRawPWM(channel, pwmValue)\n    }\n}// Add your code here\n","position.ts":"namespace position {\n\n    class OccupancyGrid {\n\n    }\n\n    export function updateSensors() {\n        //  Update Compass direction, current speed, deviation, commands coming from Bluetooth, ...\n        //  TO DO Compute current position with sensor fusion https://github.com/micropython-IMU/micropython-fusion/tree/master\n        let compass_heading = input.compassHeading()\n        let mag_x = input.magneticForce(Dimension.X)\n        let mag_y = input.magneticForce(Dimension.Y)\n        let mag_z = input.magneticForce(Dimension.Z)\n        let acc_x = input.acceleration(Dimension.X)\n        let acc_y = input.acceleration(Dimension.Y)\n        let acc_z = input.acceleration(Dimension.Z)\n        let acceleration = Math.sqrt(acc_x ** 2 + acc_y ** 2 + acc_z ** 2)\n    }\n\n    export function updateEnvironment() {\n        // re-compute the occupancy grid : QRCodes cardinals, home location, balls clusters, robots\n        // approximate the Robot orientation and position\n    }\n}","motion.ts":"namespace motion {\n\n    enum MotionDirection {\n        Idle,\n        Forward,\n        Backward,\n        Spinning\n    }\n\n    export class Waypoint {\n        distance: number  //  mm\n        angle: number // radians\n        constructor(distance: number, angle: number) {\n            this.distance = distance\n            this.angle = angle\n        }\n    }\n    \n    let waypoint = new Waypoint(0,0)\n\n    // \n    export function setWaypoint(distance: number, angle: number){\n        waypoint.distance = distance\n        waypoint.angle = angle\n    }\n\n    /*\n    ServoController.setServo(DIRECTION_SERVO, -45) //turn right\n    ServoController.setServo(DIRECTION_SERVO, 0) //straight\n    ServoController.setServo(DIRECTION_SERVO, 45) //turn left\n    MotorController.setMotor(SPEED_MOTOR, -100) //backward max speed\n    MotorController.setMotor(SPEED_MOTOR, 100) //forward max speed\n    */\n    export function goToWaypoint() {\n        //  Drive servo and motor with PWM according to updated linear and angular velocities\n        //  Set the steering servo position to aim to the waypoint\n        let steering = 0\n        //  to be computed with PID\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P0.setAngle(steering)\n        } else {\n            ServoController.setServo(DIRECTION_SERVO, steering)\n        }\n\n        //  Set the servo throttle power depending on the remaining distance to the waypoint\n        let speed = 0\n        // just for testing purpose\n        if (waypoint.distance > 60)\n            speed = 100\n        else if (waypoint.distance > 0)\n            speed = 50\n        if (EXEC_MODE == ExecMode.MakeCode) {\n            servos.P1.run(speed)\n        } else {\n            MotorController.setMotor(SPEED_MOTOR, speed)\n        }\n\n    }\n\n}\n","vision.ts":"namespace vision_ns {\n\n    const HUSKY_SCREEN_WIDTH = 320; // pixels\n    const HUSKY_SCREEN_HEIGHT = 240; // pixels\n    const HUSKY_SCREEN_CENTER_X = HUSKY_SCREEN_WIDTH / 2;\n    const HUSKY_SCREEN_CENTER_Y = HUSKY_SCREEN_HEIGHT / 2;\n    const HUSKY_SCREEN_TOLERANCE_X = 10; // pixels\n\n    const BALL_REFERENCE_DISTANCE = 50; // (cm)\n    const BALL_REFERENCE_FRAMESIZE = 30; // (pixels) width and height of a ball frame at 50 cm distance\n    const BALL_DISTANCE_RATIO = BALL_REFERENCE_DISTANCE / BALL_REFERENCE_FRAMESIZE;\n\n    // Screen Side Class\n    export enum ScreenSide {\n        Left,\n        Right,\n        Middle\n    }\n\n    // QR Codes Configuration\n    const QR_CODES = [\n        { code: \"id300\", cardinal: \"East\", husky_learned_id: 1 },\n        { code: \"id301\", cardinal: \"South\", husky_learned_id: 2 },\n        { code: \"id302\", cardinal: \"West\", husky_learned_id: 3 },\n        { code: \"id303\", cardinal: \"North\", husky_learned_id: 4 },\n        { code: \"id407\", cardinal: \"Base\", husky_learned_id: 5 }\n    ];\n\n    // QR Code ID as recognized by Husky TagRecognition\n    export class QRcodeId {\n        static East = 1;\n        static South = 2;\n        static West = 3;\n        static North = 4;\n        static Base = 5;\n    }\n\n    // Object Color ID as recognized by Husky ColorRecognition\n    export class ObjectColorID {\n        static Red = 1; // a ball\n        static Yellow = 2; // another robot\n    }\n\n    // Object Class ID as recognized by Husky ObjectClassification\n    export class ObjectClassID {\n        static Unknown = 0;\n        static Ball = 1;\n        static Robot = 2;\n        static QRcode = 3;\n    }\n\n    // Object Kind\n    export enum ObjectKind {\n        Unknown,\n        Ball,\n        Robot,\n        QRcode\n    }\n\n\n    // Visual Object Class\n    export class VisualObject {\n        public x: number = -1\n        public y: number = -1\n        public w: number = -1\n        public h: number = -1\n        public id: number = -1 // ID as returned by Huskylens \n        public kind: ObjectKind = ObjectKind.Unknown\n        public last_seen: number = -1\n        public is_tracked: boolean = false\n        constructor() {\n        }\n\n        setCoordinates(x: number, y: number, w: number, h: number) {\n            // Set the object's coordinates and dimensions. Update LastSeen time.\n            this.x = x;\n            this.y = y;\n            this.w = w;\n            this.h = h;\n            this.last_seen = input.runningTime();\n        }\n\n        reset() {\n            // Reset the object's coordinates and dimensions.\n            this.setCoordinates(0, 0, 0, 0);\n            this.last_seen = 0;\n        }\n\n        toString() {\n            // Display the object's details.\n            return `kind: ${this.kind} id: ${this.x} x:${this.x} y:${this.y} w:(${this.w} h:${this.h}`;\n        }\n\n        // Get side of the TrackedObject relative to the robot direction\n        getScreenSide() {\n            if (this.x > (HUSKY_SCREEN_CENTER_X + HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Right;\n            } else if (this.x < (HUSKY_SCREEN_CENTER_X - HUSKY_SCREEN_TOLERANCE_X)) {\n                return ScreenSide.Left;\n            } else {\n                return ScreenSide.Middle;\n            }\n        }\n\n        // Compute distance of the TrackedObject based on the visual size ratio\n        getDistance() {\n            const size = Math.sqrt(this.w ** 2 + this.h ** 2); // frame diagonal\n            return (BALL_REFERENCE_FRAMESIZE * BALL_REFERENCE_DISTANCE) / size;\n        }\n\n        // Compute coordinates of the TrackedObject relative to the robot position (origin)\n        getAngle() {\n            const distance = this.getDistance();\n            const deltaX = Math.abs(this.x - HUSKY_SCREEN_CENTER_X);\n            const deltaY = Math.sqrt(distance ** 2 - deltaX ** 2);\n            // Angle between y front-axis and the ball projected coordinates(dx,dy)\n            return Math.atan2(deltaX, deltaY);\n        }\n    }\n\n    // Vision Processor Class\n    export class VisionProcessor {\n        public mode: number\n        public kind: number\n        public tracked: VisualObject\n        public codes: VisualObject[] = [];\n        public balls: VisualObject[] = [];\n        public bots: VisualObject[] = [];\n        public verbose: boolean = true\n        constructor(mode = protocolAlgorithm.ALGORITHM_TAG_RECOGNITION, kind = ObjectKind.QRcode) {\n            this.mode = mode;\n            this.kind = kind;\n            this.tracked = new VisualObject();\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n        }\n\n        setMode(mode: number) {\n            if (this.mode !== mode) {\n                this.mode = mode;\n                huskylens.initMode(this.mode);\n                if (this.verbose) { logger.log(`Mode set to: ${this.mode}`); }\n            }\n        }\n\n        setKind(kind: number) {\n            if (this.kind !== kind) {\n                this.kind = kind;\n                if (this.verbose) { logger.log(`Kind set to: ${this.kind}`); }\n            }\n        }\n\n        init() {\n            huskylens.initI2c();\n            huskylens.initMode(this.mode);\n        }\n\n        refreshForced(mode: number, kind: number) {\n            // Change temporarily the mode and the kind to refresh all objects once\n            const saveMode = this.mode;\n            const saveKind = this.kind;\n            this.setMode(mode);\n            this.setKind(kind);\n            this.refresh();\n            this.setMode(saveMode);\n            this.setKind(saveKind);\n        }\n\n        // Capture a new video frame and analyze it : is there 1 ball, no ball, a Tag, an obstacle or nothing ?\n        refresh() {\n            // Refresh the VisionProcessor.\n            huskylens.request();\n            if (this.verbose) { logger.log(`Husky (mode  ${this.mode}) captured IDs : ${huskylens.getIds()}`) }\n            if (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING) {\n                this.processSingleObject();\n            }\n            if ((this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION)\n                || (this.mode === protocolAlgorithm.ALGORITHM_OBJECT_TRACKING)) {\n                this.processAllObjects()\n            }\n        }\n\n        processSingleObject() {\n            // Process a single object in tracking mode.\n            // Frame (== Block type) appears in screen ?\n            this.tracked.is_tracked = huskylens.isAppear_s(HUSKYLENSResultType_t.HUSKYLENSResultBlock)\n            if (this.tracked.is_tracked) {\n                // check if the tracked object is a learnt object \n                if (!huskylens.isLearned(this.kind)) {\n                    if (this.verbose) { logger.log(\"Tracking UNKNOWN object\") }\n                }\n                const objectId = this.kind; // always one single TrackedObject in this mode\n                this.tracked.setCoordinates(\n                    huskylens.readeBox(objectId, Content1.xCenter),\n                    huskylens.readeBox(objectId, Content1.yCenter),\n                    huskylens.readeBox(objectId, Content1.width),\n                    huskylens.readeBox(objectId, Content1.height)\n                );\n                if (this.verbose) { logger.log(\"Tracked Object updated : \" + this.tracked.toString()) }\n\n            } else {\n                // if (input.runningTime() - trackedObject.lastSeen) > OBJECT_LOST_DELAY:\n                this.tracked.reset();\n                if (this.verbose) { logger.log(\"Tracked Object Lost\") }\n            }\n        }\n\n        processAllObjects() {\n            // Process all objects in recognition mode.\n            this.codes = [];\n            this.balls = [];\n            this.bots = [];\n            // for each frame, Update the relative Position of the QR codes\n            const nbFrames = huskylens.getBox(HUSKYLENSResultType_t.HUSKYLENSResultBlock);\n            if (this.verbose) { logger.log(`Objects on screen : ${nbFrames}`); }\n            for (let i = 1; i <= nbFrames; i++) {\n                const vo = new VisualObject();\n                vo.id = huskylens.readBox_ss(i, Content3.ID);\n                vo.setCoordinates(\n                    huskylens.readBox_ss(i, Content3.xCenter),\n                    huskylens.readBox_ss(i, Content3.yCenter),\n                    huskylens.readBox_ss(i, Content3.width),\n                    huskylens.readBox_ss(i, Content3.height)\n                );\n\n                if (this.mode === protocolAlgorithm.ALGORITHM_TAG_RECOGNITION) {\n                    vo.kind = ObjectKind.QRcode\n                    this.codes.push(vo);\n                    if (this.verbose) { logger.log(\"QR Tag found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.ALGORITHM_COLOR_RECOGNITION) {\n                    if (vo.id === ObjectColorID.Red) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectColorID.Yellow) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Colored object found : \" + vo.toString()); }\n                }\n                if (this.mode === protocolAlgorithm.OBJECTCLASSIFICATION) {\n                    if (vo.id === ObjectClassID.Ball) {\n                        vo.kind = ObjectKind.Ball\n                        this.balls.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.Robot) {\n                        vo.kind = ObjectKind.Robot\n                        this.bots.push(vo);\n                    }\n                    if (vo.id === ObjectClassID.QRcode) {\n                        vo.kind = ObjectKind.QRcode\n                        this.codes.push(vo);\n                    }\n                    if (this.verbose) { logger.log(\"Shaped object found : \" + vo.toString()); }\n                }\n            }\n        }\n    }\n\n}\n","game.ts":"enum GameMode {\n    Free, // Free running Robot until OBEY gets received\n    Slave, // Obey to Radio instructions\n}\nenum GameState {\n    Started,\n    Stopped,\n}\nclass BricksGame {\n    mode: GameMode = GameMode.Free\n    state: GameState = GameState.Stopped\n    startTime: number = -1;\n    constructor() {\n    }\n    public remainingTime(): number {\n        if (this.state == GameState.Started) {\n            return GAME_DURATION - (control.millis() - this.startTime) / 1000;\n        }\n        else return GAME_DURATION;// any positive number would be okay\n    }\n    public setState(state: GameState) {\n        if (this.state != state) {\n            this.state = state\n            logger.log(\"Robot State changed : \" + (\"\" + this.state))\n        }\n    }\n    public doObey() {\n        // Acknowledge the command\n        //UTBController.sendObeyMe()\n        this.mode = GameMode.Slave\n        basic.showIcon(IconNames.Angry)\n        //music.setTempo(360)\n        //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.Funk), music.PlaybackMode.UntilDone)\n        logger.log(\"Robot in Slave mode\");\n    }\n    public doStart() {\n        if (this.mode == GameMode.Slave) {\n            // Acknowledge the command\n            //UTBController.sendActionStart()\n            this.setState(GameState.Started)\n            this.startTime = control.millis()\n            robot.doStart()\n            basic.showIcon(IconNames.Happy)\n            //music.setTempo(360)\n            //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerUp), music.PlaybackMode.InBackground)\n        }\n        else {\n            logger.log(\"Asked to Start but not in Slave mode\");\n        }\n    }\n    public doStop() {\n        // Acknowledge the command\n        //UTBController.sendActionStop()\n        this.setState(GameState.Stopped)\n        robot.doStop()\n        basic.showIcon(IconNames.Asleep)\n        //music.setTempo(360)\n        //music._playDefaultBackground(music.builtInPlayableMelody(Melodies.PowerDown), music.PlaybackMode.InBackground)\n    }\n    public doDanger() {\n        // Acknowledge the command\n        //UTBController.sendActionDanger()\n        robot.askGoingHome()\n        basic.showLeds(`\n            # # . # #\n            # # . # #\n            . . . . .\n            # # # # #\n            # # # # #\n            `)\n        basic.showIcon(IconNames.Surprised)\n        //music.setTempo(360)\n        //for (let index = 0; index < 4; index++) {\n        //    music._playDefaultBackground(music.builtInPlayableMelody(Melodies.BaDing), music.PlaybackMode.UntilDone)\n       // }\n    }\n}\n\n// Radio messages received from the controller\nfunction handleControllerDataReceived(receivedString: string) {\n\n}\n\n\n// Button events\nfunction initButtonsEvents() {\n    input.onButtonPressed(Button.A, function () {\n        bricksGame.doStart()\n    })\n    input.onButtonPressed(Button.AB, function () {\n        bricksGame.doStop()\n    })\n    input.onLogoEvent(TouchButtonEvent.Pressed, function () {\n        bricksGame.doObey()\n    })\n    input.onButtonPressed(Button.B, function () {\n        bricksGame.doDanger()\n    })\n    // Logo Button Long Pressed to change the radio group\n    input.onLogoEvent(TouchButtonEvent.LongPressed, function () {\n        //UTBRadio.showRadioGroup()\n        //UTBRadio.incrementRadioGroup()\n        //UTBRadio.showRadioGroup()\n    })\n}\n\n// Radio events\nserial.onDataReceived(serial.delimiters(Delimiters.NewLine), function () {\n    handleControllerDataReceived(serial.readLine())\n})\n\nfunction initGameController() {\n    //UTBController.initAsController()\n    //UTBRadio.showRadioGroup()\n}\n/*\n//source : https://github.com/Taccart/amaker-unleash-the-brick-example/blob/master/main.ts\nUnleashTheBricks.setLogLevel(LogLevel.Debug)\nUnleashTheBricks.setEchoToConsole(true)\nUnleashTheBricks.initCommunicationChannel(CommunicationChannel.Radio)\nUnleashTheBricks.setBotStatus(BotStatus.Searching)\nUnleashTheBricks.setBotStatus(BotStatus.Capturing)\nUnleashTheBricks.setBotStatus(BotStatus.BringingBack)\nbasic.forever(function () {\n    UnleashTheBricks.emitHeartBeat()\n    control.waitMicros(10000000)\n})\n*/","robot.ts":"enum RobotState {\n    stopped,       //Game.State == Stopped\n    waiting,       //Game.State == Stopped, Game.Mode == Slave\n    searchingBalls,//Game.State == Started\n    trackingBall,  //Game.State == Started\n    searchingHome, //Game.State == Started\n    goingHome,     //Game.State == Started\n    atHome // when at home, send status  <name>:<timer> mission:safe_place_reached, wait 5s then resume\n}\n\n\nclass Robot {\n    state: number\n    //waypoint: motion.Waypoint\n    constructor() {\n        this.state = RobotState.waiting\n    }\n\n    public setState(state: number) {\n        if (this.state != state) {\n            this.state = state\n            logger.log(\"Robot State changed : \" + this.state)\n            switch (this.state) {\n                case RobotState.stopped:\n                case RobotState.atHome:\n                case RobotState.searchingBalls:\n                case RobotState.searchingHome:\n                case RobotState.trackingBall:\n                case RobotState.goingHome:\n                    break\n                default:\n                    break\n            }\n        }\n\n    }\n\n    // Externel explicit state changes\n    public doStart() {\n        logger.log(\"Game started at \" + bricksGame.startTime + \" . Starting collecting balls...\")\n        MotorController.setMotor(GRABBER_MOTOR, -50) //grab\n        this.setState(RobotState.searchingBalls)\n    }\n    public doStop() {\n        logger.log(\"Game Stopped. Stopping collecting balls.\")\n        MotorController.setMotor(GRABBER_MOTOR, 0) //stop grabbing\n        this.setState(RobotState.stopped)\n    }\n    public askGoingHome() {\n        logger.log(\"Should I go home ?\")\n        //we can decide to ignore or not the instruction from Game controller\n    }\n    public doGoHome() {\n        logger.log(\"Going home. If location unknown, look for it.\")\n        // no more balls, or time is over, or acknolewdging danger mode\n        this.setState(RobotState.searchingHome)\n    }\n\n    // Autonomous decision making\n    public updateObjective() {\n        //  Based on input signals, current position, object recgnition and game instructions\n        //  determine the next action and next state\n        // \n        //  Condition 1 : get closer to the home before the end of the game\n        //  (TO DO : consider distance_to_home)\n        //logger.log(\"Remaining time \" + bricksGame.remainingTime())\n        if ((bricksGame.remainingTime() < DELAY_TO_GO_HOME)\n            && (this.state != RobotState.searchingHome)\n            && (this.state != RobotState.goingHome)\n            && (this.state != RobotState.atHome)) {\n            logger.log(\"########### GO HOME ###################\")\n            this.doGoHome()\n        }\n        if (bricksGame.remainingTime() < 0) {\n            logger.log(\"########### STOP  ###################\")\n            this.doStop()\n        }\n        // While waiting for the game to start\n        // we could also spin left/right and look at the balls and QR Codes\n        if (this.state == RobotState.searchingBalls) {\n            if (vision.balls.length > 0) {\n                logger.log(\"Found Balls on screen : \" + vision.balls.length)\n                this.setState(RobotState.trackingBall)\n                // TO DO define waypoint to the closest or the most centered ball\n            }\n            else {\n                logger.log(\"Keep searching...\")\n                // TO DO we need to spin randomly or to head to the latest know ball location\n            }\n        }\n        if (this.state == RobotState.trackingBall) {\n            if (vision.balls.length == 0) {\n                logger.log(\"Previous ball LOST or COLLECTED. Back to searching...(on screen Balls: \" + vision.balls.length + \")\")\n                this.setState(RobotState.searchingBalls)\n            }\n            else {\n                logger.log(\"Tracking the closest ball... (on screen Balls: \" + vision.balls.length + \")\")\n                // TO DO update waypoint to the closest or the most centered ball\n            }\n        }\n\n\n        //  Condition 2 : ...\n\n        //  Condition 3 : ...\n\n    }\n\n    // Motion decision\n    public computeNextWaypoint() {\n        // Based on the Robot State, Goal and Environment\n        // Determine the next waypoint to reach, and linear and angular velocities to reach it\n        // if tracking a VisualObject : compute the angle compared to screen center\n        // if heading blindly to a direction : compute the angle compared to compass orientation\n        // if explicit movement (spinRight, spinLeft, ...) : use the compass too\n        switch (this.state) {\n            case RobotState.stopped:\n            case RobotState.atHome:\n                motion.setWaypoint(0, 0)\n                break\n            case RobotState.searchingBalls:\n                // we are likely spinning around\n                break\n            case RobotState.searchingHome:\n                // we are likely spinning around\n                break\n            case RobotState.trackingBall:\n                // waypoint == closest ball on Camera\n                break\n            case RobotState.goingHome:\n                // waypoint == QRCode on Camera\n                break\n            default:\n                break\n        }\n    }\n}","pxt.json":"{\n    \"name\": \"CybertruckJS\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"datalogger\": \"*\",\n        \"servo\": \"*\",\n        \"Huskylens\": \"github:dfrobot/pxt-dfrobot_huskylens#v2.0.7\"\n    },\n    \"files\": [\n        \"main.ts\",\n        \"README.md\",\n        \"logger.ts\",\n        \"controller.ts\",\n        \"position.ts\",\n        \"motion.ts\",\n        \"vision.ts\",\n        \"game.ts\",\n        \"robot.ts\"\n    ],\n    \"preferredEditor\": \"tsprj\",\n    \"languageRestriction\": \"javascript-only\"\n}\n"}}],"shares":[],"lastSaveTime":1759764374671}